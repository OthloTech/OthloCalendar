{"version":3,"sources":["webpack:///bundle.js","webpack:///webpack/bootstrap 423edeb7959157fa994e","webpack:///./~/css-loader/lib/css-base.js","webpack:///./~/riot/riot.js","webpack:///./~/style-loader/addStyles.js","webpack:///./client/index.js","webpack:///./client/app.tag","webpack:///./client/stylesheets/default-hljs.scss","webpack:///./client/stylesheets/flex-grid.scss","webpack:///./client/stylesheets/normalize.scss","webpack:///./client/stylesheets/default-hljs.scss?098b","webpack:///./client/stylesheets/flex-grid.scss?e67c","webpack:///./client/stylesheets/normalize.scss?575b"],"names":["modules","__webpack_require__","moduleId","installedModules","exports","module","id","loaded","call","m","c","p","list","toString","result","i","this","length","item","push","join","mediaQuery","alreadyImportedModules","riot","global","factory","isSVGTag","name","RE_SVG_TAGS","test","isBoolAttr","value","RE_BOOL_ATTRS","isFunction","T_FUNCTION","isObject","T_OBJECT","isUndefined","T_UNDEF","isString","T_STRING","isBlank","isArray","Array","isWritable","obj","key","descriptor","Object","getOwnPropertyDescriptor","writable","isReservedName","RE_RESERVED_NAMES","$$","selector","ctx","document","querySelectorAll","$","querySelector","createFrag","createDocumentFragment","createDOMPlaceholder","createTextNode","mkEl","isSvg","createElementNS","createElement","getOuterHTML","el","outerHTML","container","appendChild","cloneNode","innerHTML","setInnerHTML","html","doc","DOMParser","parseFromString","node","ownerDocument","importNode","documentElement","remAttr","dom","removeAttribute","getAttr","getAttribute","setAttr","val","xlink","XLINK_REGEX","exec","setAttributeNS","XLINK_NS","setAttribute","safeInsert","root","curr","next","insertBefore","parentNode","walkAttrs","fn","RE_HTML_ATTRS","toLowerCase","walkNodes","context","res","firstChild","nextSibling","each","len","contains","array","indexOf","toCamel","str","replace","_","toUpperCase","startsWith","slice","defineProperty","options","extend","enumerable","configurable","src","args","arguments","handleEvent","handler","e","ptag","_parent","_item","currentTarget","target","srcElement","which","charCode","keyCode","preventUpdate","getImmediateCustomParentTag","isMounted","update","setEventHandler","tag","eventName","cb","bind","addEventListener","EVENTS_PREFIX_REGEX","_riotEvents","removeEventListener","updateDataIs","expr","parent","conf","tagName","tmpl","delName","tags","RIOT_TAG_IS","arrayishRemove","impl","__TAG_IMPL","hasImpl","initChildTag","mount","on","opts","dataIs","_tags","unmount","updateExpression","old","attrName","attr","isValueAttr","isVirtual","bool","_riot_id","frag","makeVirtual","parentElement","replaceChild","isRtag","IE_VERSION","nodeValue","isAttrRemoved","style","display","RIOT_PREFIX","update$1$1","expressions","mkitem","base","create","pos","unmountRedundant","items","t","j","splice","moveNestedTags","this$1","keys","moveChildTag","apply","move","nextTag","moveVirtual","insert","append","_each","hasKeys","mustReorder","getTagName","useRoot","RE_SPECIAL_TAGS","ref","child","getTag","ifExpr","oldItems","isLoop","isAnonymous","loopKeys","removeChild","placeholder","map","filter","_mustReorder","oldPos","mustAppend","Tag$$1","arrayishAdd","parseExpressions","mustIncludeRoot","tree","children","tagImpl","type","nodeType","hasExpr","IfExpr","init","parseAttributes","attributes","attrs","RefExpr","specialTags","select","trim","selectedIndex","tname","rootEls","childElementCount","replaceYield","reHasYield","reYieldSrc","text","reYieldDest","def","reYieldAll","mkdom","checkSvg","match","GENERIC","tblTags","stub","Tag$1","css","onCreate","tag$$1","class","constructor","mountTo","styleManager","inject","add","tag2$$1","exists","util","hotReloader","mount$$1","pushTagsTo","riotTag","elem","allTags","selectTags","split","nodeList","_el","mixin$$1","mix","g","_id","store","globals","mixins","Error","prototype","update$2","__TAGS_CACHE","unregister$$1","updateOpts","instAttrs","cleanUpData","implAttrs","propsInSyncWithParent","observable","_tag","virts","tail","head","__uid","data","shouldUpdate","inheritFrom","trigger","instance","props","proto","getPrototypeOf","concat","getOwnPropertyNames","hasGetterSetter","get","set","hasOwnProperty","isPrototypeOf","k","v","globalMixin","GLOBAL_MIXIN","mixin","one","mustKeepRoot","tagIndex","forEach","_internal","unmountAll","a","off","mustSync","newPos","skipDataIs","namedTag","o","ensureArray","dest","isArr","isInStub","inStub","implClass","_innerHTML","sib","reduce","styleNode","cssTextProp","WIN","window","undefined","RE_SPECIAL_TAGS_NO_OPTION","documentMode","check","freeze","byName","remainder","newNode","userNode","getElementsByTagName","styleSheet","cssText","brackets","UNDEF","_loopback","re","_rewrite","bp","_cache","RegExp","source","REGLOB","_create","pair","DEFAULT","_pairs","arr","UNSUPPORTED","NEED_ESCAPE","S_QBLOCKS","_brackets","reOrIdx","_regex","_reset","cachedBrackets","_setSettings","b","_settings","R_MLCOMMS","R_STRINGS","FINDBRACES","(","[","{","_bp","unescapeStr","s","isexpr","parts","skipBraces","ch","ix","recch","lastIndex","start","index","settings","_tmpl","_logErr","err","riotData","errorHandler","console","error","_getTmpl","Function","qstr","RE_DQUOTE","_parseExpr","RE_QBMARK","asText","mm","lv","ir","RE_BREND","RE_QBLOCK","div","CH_IDEXPR","cnt","RE_CSNAME","jsb","rightContext","_wrapExpr","tb","JS_VARNAME","mvar","JS_CONTEXT","JS_NOPROPS","clearCache","String","fromCharCode","version","misc","callbacks","defineProperties","event","fns","arguments$1","arglen","parentTag","pristine","newValue","current","attrValue","rawValue","hasExp","firstRun","customParent","tagOrDom","refs","tr","th","td","col","vdom","Tag","tag2","unregister","addStylesToDom","styles","domStyle","stylesInDom","addStyle","listToStyles","newStyles","media","sourceMap","part","insertStyleElement","styleElement","getHeadElement","lastStyleElementInsertedAtTop","styleElementsInsertedAtTop","insertAt","removeStyleElement","idx","createStyleElement","createLinkElement","linkElement","rel","remove","singleton","styleIndex","singletonCounter","singletonElement","applyToSingletonTag","URL","createObjectURL","revokeObjectURL","Blob","btoa","updateLink","href","applyToTag","newObj","replaceText","cssNode","childNodes","unescape","encodeURIComponent","JSON","stringify","blob","oldSrc","memoize","memo","isOldIE","navigator","userAgent","newList","mayRemove","textStore","replacement","Boolean","content","locals"],"mappings":"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","file":"bundle.js","sourcesContent":["/******/ (function(modules) { // webpackBootstrap\n/******/ \t// The module cache\n/******/ \tvar installedModules = {};\n/******/\n/******/ \t// The require function\n/******/ \tfunction __webpack_require__(moduleId) {\n/******/\n/******/ \t\t// Check if module is in cache\n/******/ \t\tif(installedModules[moduleId])\n/******/ \t\t\treturn installedModules[moduleId].exports;\n/******/\n/******/ \t\t// Create a new module (and put it into the cache)\n/******/ \t\tvar module = installedModules[moduleId] = {\n/******/ \t\t\texports: {},\n/******/ \t\t\tid: moduleId,\n/******/ \t\t\tloaded: false\n/******/ \t\t};\n/******/\n/******/ \t\t// Execute the module function\n/******/ \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n/******/\n/******/ \t\t// Flag the module as loaded\n/******/ \t\tmodule.loaded = true;\n/******/\n/******/ \t\t// Return the exports of the module\n/******/ \t\treturn module.exports;\n/******/ \t}\n/******/\n/******/\n/******/ \t// expose the modules object (__webpack_modules__)\n/******/ \t__webpack_require__.m = modules;\n/******/\n/******/ \t// expose the module cache\n/******/ \t__webpack_require__.c = installedModules;\n/******/\n/******/ \t// __webpack_public_path__\n/******/ \t__webpack_require__.p = \"/dist/\";\n/******/\n/******/ \t// Load entry module and return exports\n/******/ \treturn __webpack_require__(0);\n/******/ })\n/************************************************************************/\n/******/ ([\n/* 0 */\n/*!******************!*\\\n  !*** multi main ***!\n  \\******************/\n/***/ function(module, exports, __webpack_require__) {\n\n\tmodule.exports = __webpack_require__(/*! ./client/index */4);\n\n\n/***/ },\n/* 1 */\n/*!**************************************!*\\\n  !*** ./~/css-loader/lib/css-base.js ***!\n  \\**************************************/\n/***/ function(module, exports) {\n\n\t/*\r\n\t\tMIT License http://www.opensource.org/licenses/mit-license.php\r\n\t\tAuthor Tobias Koppers @sokra\r\n\t*/\r\n\t// css base code, injected by the css-loader\r\n\tmodule.exports = function() {\r\n\t\tvar list = [];\r\n\t\r\n\t\t// return the list of modules as css string\r\n\t\tlist.toString = function toString() {\r\n\t\t\tvar result = [];\r\n\t\t\tfor(var i = 0; i < this.length; i++) {\r\n\t\t\t\tvar item = this[i];\r\n\t\t\t\tif(item[2]) {\r\n\t\t\t\t\tresult.push(\"@media \" + item[2] + \"{\" + item[1] + \"}\");\r\n\t\t\t\t} else {\r\n\t\t\t\t\tresult.push(item[1]);\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\treturn result.join(\"\");\r\n\t\t};\r\n\t\r\n\t\t// import a list of modules into the list\r\n\t\tlist.i = function(modules, mediaQuery) {\r\n\t\t\tif(typeof modules === \"string\")\r\n\t\t\t\tmodules = [[null, modules, \"\"]];\r\n\t\t\tvar alreadyImportedModules = {};\r\n\t\t\tfor(var i = 0; i < this.length; i++) {\r\n\t\t\t\tvar id = this[i][0];\r\n\t\t\t\tif(typeof id === \"number\")\r\n\t\t\t\t\talreadyImportedModules[id] = true;\r\n\t\t\t}\r\n\t\t\tfor(i = 0; i < modules.length; i++) {\r\n\t\t\t\tvar item = modules[i];\r\n\t\t\t\t// skip already imported module\r\n\t\t\t\t// this implementation is not 100% perfect for weird media query combinations\r\n\t\t\t\t//  when a module is imported multiple times with different media queries.\r\n\t\t\t\t//  I hope this will never occur (Hey this way we have smaller bundles)\r\n\t\t\t\tif(typeof item[0] !== \"number\" || !alreadyImportedModules[item[0]]) {\r\n\t\t\t\t\tif(mediaQuery && !item[2]) {\r\n\t\t\t\t\t\titem[2] = mediaQuery;\r\n\t\t\t\t\t} else if(mediaQuery) {\r\n\t\t\t\t\t\titem[2] = \"(\" + item[2] + \") and (\" + mediaQuery + \")\";\r\n\t\t\t\t\t}\r\n\t\t\t\t\tlist.push(item);\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t};\r\n\t\treturn list;\r\n\t};\r\n\n\n/***/ },\n/* 2 */\n/*!************************!*\\\n  !*** ./~/riot/riot.js ***!\n  \\************************/\n/***/ function(module, exports, __webpack_require__) {\n\n\t/* WEBPACK VAR INJECTION */(function(riot) {/* Riot v3.0.1, @license MIT */\n\t(function (global, factory) {\n\t   true ? factory(exports) :\n\t  typeof define === 'function' && define.amd ? define(['exports'], factory) :\n\t  (factory((global.riot = global.riot || {})));\n\t}(this, (function (exports) { 'use strict';\n\t\n\tvar __TAGS_CACHE = [];\n\tvar __TAG_IMPL = {};\n\tvar GLOBAL_MIXIN = '__global_mixin';\n\tvar RIOT_PREFIX = 'riot-';\n\tvar RIOT_TAG_IS = 'data-is';\n\tvar T_STRING = 'string';\n\tvar T_OBJECT = 'object';\n\tvar T_UNDEF  = 'undefined';\n\tvar T_FUNCTION = 'function';\n\tvar XLINK_NS = 'http://www.w3.org/1999/xlink';\n\tvar XLINK_REGEX = /^xlink:(\\w+)/;\n\tvar WIN = typeof window === T_UNDEF ? undefined : window;\n\tvar RE_SPECIAL_TAGS = /^(?:t(?:body|head|foot|[rhd])|caption|col(?:group)?|opt(?:ion|group))$/;\n\tvar RE_SPECIAL_TAGS_NO_OPTION = /^(?:t(?:body|head|foot|[rhd])|caption|col(?:group)?)$/;\n\tvar RE_RESERVED_NAMES = /^(?:_(?:item|id|parent)|update|root|(?:un)?mount|mixin|is(?:Mounted|Loop)|tags|refs|parent|opts|trigger|o(?:n|ff|ne))$/;\n\tvar RE_SVG_TAGS = /^(altGlyph|animate(?:Color)?|circle|clipPath|defs|ellipse|fe(?:Blend|ColorMatrix|ComponentTransfer|Composite|ConvolveMatrix|DiffuseLighting|DisplacementMap|Flood|GaussianBlur|Image|Merge|Morphology|Offset|SpecularLighting|Tile|Turbulence)|filter|font|foreignObject|g(?:lyph)?(?:Ref)?|image|line(?:arGradient)?|ma(?:rker|sk)|missing-glyph|path|pattern|poly(?:gon|line)|radialGradient|rect|stop|svg|switch|symbol|text(?:Path)?|tref|tspan|use)$/;\n\tvar RE_HTML_ATTRS = /([-\\w]+) ?= ?(?:\"([^\"]*)|'([^']*)|({[^}]*}))/g;\n\tvar RE_BOOL_ATTRS = /^(?:disabled|checked|readonly|required|allowfullscreen|auto(?:focus|play)|compact|controls|default|formnovalidate|hidden|ismap|itemscope|loop|multiple|muted|no(?:resize|shade|validate|wrap)?|open|reversed|seamless|selected|sortable|truespeed|typemustmatch)$/;\n\tvar IE_VERSION = (WIN && WIN.document || {}).documentMode | 0;\n\t\n\t/**\n\t * Check whether a DOM node must be considered a part of an svg document\n\t * @param   { String } name -\n\t * @returns { Boolean } -\n\t */\n\tfunction isSVGTag(name) {\n\t  return RE_SVG_TAGS.test(name)\n\t}\n\t\n\t/**\n\t * Check Check if the passed argument is undefined\n\t * @param   { String } value -\n\t * @returns { Boolean } -\n\t */\n\tfunction isBoolAttr(value) {\n\t  return RE_BOOL_ATTRS.test(value)\n\t}\n\t\n\t/**\n\t * Check if passed argument is a function\n\t * @param   { * } value -\n\t * @returns { Boolean } -\n\t */\n\tfunction isFunction(value) {\n\t  return typeof value === T_FUNCTION || false // avoid IE problems\n\t}\n\t\n\t/**\n\t * Check if passed argument is an object, exclude null\n\t * NOTE: use isObject(x) && !isArray(x) to excludes arrays.\n\t * @param   { * } value -\n\t * @returns { Boolean } -\n\t */\n\tfunction isObject(value) {\n\t  return value && typeof value === T_OBJECT // typeof null is 'object'\n\t}\n\t\n\t/**\n\t * Check if passed argument is undefined\n\t * @param   { * } value -\n\t * @returns { Boolean } -\n\t */\n\tfunction isUndefined(value) {\n\t  return typeof value === T_UNDEF\n\t}\n\t\n\t/**\n\t * Check if passed argument is a string\n\t * @param   { * } value -\n\t * @returns { Boolean } -\n\t */\n\tfunction isString(value) {\n\t  return typeof value === T_STRING\n\t}\n\t\n\t/**\n\t * Check if passed argument is empty. Different from falsy, because we dont consider 0 or false to be blank\n\t * @param { * } value -\n\t * @returns { Boolean } -\n\t */\n\tfunction isBlank(value) {\n\t  return isUndefined(value) || value === null || value === ''\n\t}\n\t\n\t/**\n\t * Check if passed argument is a kind of array\n\t * @param   { * } value -\n\t * @returns { Boolean } -\n\t */\n\tfunction isArray(value) {\n\t  return Array.isArray(value) || value instanceof Array\n\t}\n\t\n\t/**\n\t * Check whether object's property could be overridden\n\t * @param   { Object }  obj - source object\n\t * @param   { String }  key - object property\n\t * @returns { Boolean } -\n\t */\n\tfunction isWritable(obj, key) {\n\t  var descriptor = Object.getOwnPropertyDescriptor(obj, key);\n\t  return isUndefined(obj[key]) || descriptor && descriptor.writable\n\t}\n\t\n\t/**\n\t * Check if passed argument is a reserved name\n\t * @param   { String } value -\n\t * @returns { Boolean } -\n\t */\n\tfunction isReservedName(value) {\n\t  return RE_RESERVED_NAMES.test(value)\n\t}\n\t\n\tvar check = Object.freeze({\n\t\tisSVGTag: isSVGTag,\n\t\tisBoolAttr: isBoolAttr,\n\t\tisFunction: isFunction,\n\t\tisObject: isObject,\n\t\tisUndefined: isUndefined,\n\t\tisString: isString,\n\t\tisBlank: isBlank,\n\t\tisArray: isArray,\n\t\tisWritable: isWritable,\n\t\tisReservedName: isReservedName\n\t});\n\t\n\t/**\n\t * Shorter and fast way to select multiple nodes in the DOM\n\t * @param   { String } selector - DOM selector\n\t * @param   { Object } ctx - DOM node where the targets of our search will is located\n\t * @returns { Object } dom nodes found\n\t */\n\tfunction $$(selector, ctx) {\n\t  return (ctx || document).querySelectorAll(selector)\n\t}\n\t\n\t/**\n\t * Shorter and fast way to select a single node in the DOM\n\t * @param   { String } selector - unique dom selector\n\t * @param   { Object } ctx - DOM node where the target of our search will is located\n\t * @returns { Object } dom node found\n\t */\n\tfunction $(selector, ctx) {\n\t  return (ctx || document).querySelector(selector)\n\t}\n\t\n\t/**\n\t * Create a document fragment\n\t * @returns { Object } document fragment\n\t */\n\tfunction createFrag() {\n\t  return document.createDocumentFragment()\n\t}\n\t\n\t/**\n\t * Create a document text node\n\t * @returns { Object } create a text node to use as placeholder\n\t */\n\tfunction createDOMPlaceholder() {\n\t  return document.createTextNode('')\n\t}\n\t\n\t/**\n\t * Create a generic DOM node\n\t * @param   { String } name - name of the DOM node we want to create\n\t * @param   { Boolean } isSvg - should we use a SVG as parent node?\n\t * @returns { Object } DOM node just created\n\t */\n\tfunction mkEl(name, isSvg) {\n\t  return isSvg ?\n\t    document.createElementNS('http://www.w3.org/2000/svg', 'svg') :\n\t    document.createElement(name)\n\t}\n\t\n\t/**\n\t * Get the outer html of any DOM node SVGs included\n\t * @param   { Object } el - DOM node to parse\n\t * @returns { String } el.outerHTML\n\t */\n\tfunction getOuterHTML(el) {\n\t  if (el.outerHTML)\n\t    { return el.outerHTML }\n\t  // some browsers do not support outerHTML on the SVGs tags\n\t  else {\n\t    var container = mkEl('div');\n\t    container.appendChild(el.cloneNode(true));\n\t    return container.innerHTML\n\t  }\n\t}\n\t\n\t/**\n\t * Set the inner html of any DOM node SVGs included\n\t * @param { Object } container - DOM node where we'll inject new html\n\t * @param { String } html - html to inject\n\t */\n\tfunction setInnerHTML(container, html) {\n\t  if (!isUndefined(container.innerHTML))\n\t    { container.innerHTML = html; }\n\t    // some browsers do not support innerHTML on the SVGs tags\n\t  else {\n\t    var doc = new DOMParser().parseFromString(html, 'application/xml');\n\t    var node = container.ownerDocument.importNode(doc.documentElement, true);\n\t    container.appendChild(node);\n\t  }\n\t}\n\t\n\t/**\n\t * Remove any DOM attribute from a node\n\t * @param   { Object } dom - DOM node we want to update\n\t * @param   { String } name - name of the property we want to remove\n\t */\n\tfunction remAttr(dom, name) {\n\t  dom.removeAttribute(name);\n\t}\n\t\n\t/**\n\t * Get the value of any DOM attribute on a node\n\t * @param   { Object } dom - DOM node we want to parse\n\t * @param   { String } name - name of the attribute we want to get\n\t * @returns { String | undefined } name of the node attribute whether it exists\n\t */\n\tfunction getAttr(dom, name) {\n\t  return dom.getAttribute(name)\n\t}\n\t\n\t/**\n\t * Set any DOM attribute\n\t * @param { Object } dom - DOM node we want to update\n\t * @param { String } name - name of the property we want to set\n\t * @param { String } val - value of the property we want to set\n\t */\n\tfunction setAttr(dom, name, val) {\n\t  var xlink = XLINK_REGEX.exec(name);\n\t  if (xlink && xlink[1])\n\t    { dom.setAttributeNS(XLINK_NS, xlink[1], val); }\n\t  else\n\t    { dom.setAttribute(name, val); }\n\t}\n\t\n\t/**\n\t * Insert safely a tag to fix #1962 #1649\n\t * @param   { HTMLElement } root - children container\n\t * @param   { HTMLElement } curr - node to insert\n\t * @param   { HTMLElement } next - node that should preceed the current node inserted\n\t */\n\tfunction safeInsert(root, curr, next) {\n\t  root.insertBefore(curr, next.parentNode && next);\n\t}\n\t\n\t/**\n\t * Minimize risk: only zero or one _space_ between attr & value\n\t * @param   { String }   html - html string we want to parse\n\t * @param   { Function } fn - callback function to apply on any attribute found\n\t */\n\tfunction walkAttrs(html, fn) {\n\t  if (!html)\n\t    { return }\n\t  var m;\n\t  while (m = RE_HTML_ATTRS.exec(html))\n\t    { fn(m[1].toLowerCase(), m[2] || m[3] || m[4]); }\n\t}\n\t\n\t/**\n\t * Walk down recursively all the children tags starting dom node\n\t * @param   { Object }   dom - starting node where we will start the recursion\n\t * @param   { Function } fn - callback to transform the child node just found\n\t * @param   { Object }   context - fn can optionally return an object, which is passed to children\n\t */\n\tfunction walkNodes(dom, fn, context) {\n\t  if (dom) {\n\t    var res = fn(dom, context);\n\t    var next;\n\t    // stop the recursion\n\t    if (res === false) { return }\n\t\n\t    dom = dom.firstChild;\n\t\n\t    while (dom) {\n\t      next = dom.nextSibling;\n\t      walkNodes(dom, fn, res);\n\t      dom = next;\n\t    }\n\t  }\n\t}\n\t\n\tvar dom = Object.freeze({\n\t\t$$: $$,\n\t\t$: $,\n\t\tcreateFrag: createFrag,\n\t\tcreateDOMPlaceholder: createDOMPlaceholder,\n\t\tmkEl: mkEl,\n\t\tgetOuterHTML: getOuterHTML,\n\t\tsetInnerHTML: setInnerHTML,\n\t\tremAttr: remAttr,\n\t\tgetAttr: getAttr,\n\t\tsetAttr: setAttr,\n\t\tsafeInsert: safeInsert,\n\t\twalkAttrs: walkAttrs,\n\t\twalkNodes: walkNodes\n\t});\n\t\n\tvar styleNode;\n\tvar cssTextProp;\n\tvar byName = {};\n\tvar remainder = [];\n\t\n\t// skip the following code on the server\n\tif (WIN) {\n\t  styleNode = (function () {\n\t    // create a new style element with the correct type\n\t    var newNode = mkEl('style');\n\t    setAttr(newNode, 'type', 'text/css');\n\t\n\t    // replace any user node or insert the new one into the head\n\t    var userNode = $('style[type=riot]');\n\t    if (userNode) {\n\t      if (userNode.id) { newNode.id = userNode.id; }\n\t      userNode.parentNode.replaceChild(newNode, userNode);\n\t    }\n\t    else { document.getElementsByTagName('head')[0].appendChild(newNode); }\n\t\n\t    return newNode\n\t  })();\n\t  cssTextProp = styleNode.styleSheet;\n\t}\n\t\n\t/**\n\t * Object that will be used to inject and manage the css of every tag instance\n\t */\n\tvar styleManager = {\n\t  styleNode: styleNode,\n\t  /**\n\t   * Save a tag style to be later injected into DOM\n\t   * @param { String } css - css string\n\t   * @param { String } name - if it's passed we will map the css to a tagname\n\t   */\n\t  add: function add(css, name) {\n\t    if (name) { byName[name] = css; }\n\t    else { remainder.push(css); }\n\t  },\n\t  /**\n\t   * Inject all previously saved tag styles into DOM\n\t   * innerHTML seems slow: http://jsperf.com/riot-insert-style\n\t   */\n\t  inject: function inject() {\n\t    if (!WIN) { return }\n\t    var style = Object.keys(byName)\n\t      .map(function(k) { return byName[k] })\n\t      .concat(remainder).join('\\n');\n\t    if (cssTextProp) { cssTextProp.cssText = style; }\n\t    else { styleNode.innerHTML = style; }\n\t  }\n\t};\n\t\n\t/**\n\t * The riot template engine\n\t * @version v3.0.0\n\t */\n\t/**\n\t * riot.util.brackets\n\t *\n\t * - `brackets    ` - Returns a string or regex based on its parameter\n\t * - `brackets.set` - Change the current riot brackets\n\t *\n\t * @module\n\t */\n\t\n\t/* global riot */\n\t\n\tvar brackets = (function (UNDEF) {\n\t\n\t  var\n\t    REGLOB = 'g',\n\t\n\t    R_MLCOMMS = /\\/\\*[^*]*\\*+(?:[^*\\/][^*]*\\*+)*\\//g,\n\t\n\t    R_STRINGS = /\"[^\"\\\\]*(?:\\\\[\\S\\s][^\"\\\\]*)*\"|'[^'\\\\]*(?:\\\\[\\S\\s][^'\\\\]*)*'/g,\n\t\n\t    S_QBLOCKS = R_STRINGS.source + '|' +\n\t      /(?:\\breturn\\s+|(?:[$\\w\\)\\]]|\\+\\+|--)\\s*(\\/)(?![*\\/]))/.source + '|' +\n\t      /\\/(?=[^*\\/])[^[\\/\\\\]*(?:(?:\\[(?:\\\\.|[^\\]\\\\]*)*\\]|\\\\.)[^[\\/\\\\]*)*?(\\/)[gim]*/.source,\n\t\n\t    UNSUPPORTED = RegExp('[\\\\' + 'x00-\\\\x1F<>a-zA-Z0-9\\'\",;\\\\\\\\]'),\n\t\n\t    NEED_ESCAPE = /(?=[[\\]()*+?.^$|])/g,\n\t\n\t    FINDBRACES = {\n\t      '(': RegExp('([()])|'   + S_QBLOCKS, REGLOB),\n\t      '[': RegExp('([[\\\\]])|' + S_QBLOCKS, REGLOB),\n\t      '{': RegExp('([{}])|'   + S_QBLOCKS, REGLOB)\n\t    },\n\t\n\t    DEFAULT = '{ }';\n\t\n\t  var _pairs = [\n\t    '{', '}',\n\t    '{', '}',\n\t    /{[^}]*}/,\n\t    /\\\\([{}])/g,\n\t    /\\\\({)|{/g,\n\t    RegExp('\\\\\\\\(})|([[({])|(})|' + S_QBLOCKS, REGLOB),\n\t    DEFAULT,\n\t    /^\\s*{\\^?\\s*([$\\w]+)(?:\\s*,\\s*(\\S+))?\\s+in\\s+(\\S.*)\\s*}/,\n\t    /(^|[^\\\\]){=[\\S\\s]*?}/\n\t  ];\n\t\n\t  var\n\t    cachedBrackets = UNDEF,\n\t    _regex,\n\t    _cache = [],\n\t    _settings;\n\t\n\t  function _loopback (re) { return re }\n\t\n\t  function _rewrite (re, bp) {\n\t    if (!bp) { bp = _cache; }\n\t    return new RegExp(\n\t      re.source.replace(/{/g, bp[2]).replace(/}/g, bp[3]), re.global ? REGLOB : ''\n\t    )\n\t  }\n\t\n\t  function _create (pair) {\n\t    if (pair === DEFAULT) { return _pairs }\n\t\n\t    var arr = pair.split(' ');\n\t\n\t    if (arr.length !== 2 || UNSUPPORTED.test(pair)) {\n\t      throw new Error('Unsupported brackets \"' + pair + '\"')\n\t    }\n\t    arr = arr.concat(pair.replace(NEED_ESCAPE, '\\\\').split(' '));\n\t\n\t    arr[4] = _rewrite(arr[1].length > 1 ? /{[\\S\\s]*?}/ : _pairs[4], arr);\n\t    arr[5] = _rewrite(pair.length > 3 ? /\\\\({|})/g : _pairs[5], arr);\n\t    arr[6] = _rewrite(_pairs[6], arr);\n\t    arr[7] = RegExp('\\\\\\\\(' + arr[3] + ')|([[({])|(' + arr[3] + ')|' + S_QBLOCKS, REGLOB);\n\t    arr[8] = pair;\n\t    return arr\n\t  }\n\t\n\t  function _brackets (reOrIdx) {\n\t    return reOrIdx instanceof RegExp ? _regex(reOrIdx) : _cache[reOrIdx]\n\t  }\n\t\n\t  _brackets.split = function split (str, tmpl, _bp) {\n\t    // istanbul ignore next: _bp is for the compiler\n\t    if (!_bp) { _bp = _cache; }\n\t\n\t    var\n\t      parts = [],\n\t      match,\n\t      isexpr,\n\t      start,\n\t      pos,\n\t      re = _bp[6];\n\t\n\t    isexpr = start = re.lastIndex = 0;\n\t\n\t    while ((match = re.exec(str))) {\n\t\n\t      pos = match.index;\n\t\n\t      if (isexpr) {\n\t\n\t        if (match[2]) {\n\t          re.lastIndex = skipBraces(str, match[2], re.lastIndex);\n\t          continue\n\t        }\n\t        if (!match[3]) {\n\t          continue\n\t        }\n\t      }\n\t\n\t      if (!match[1]) {\n\t        unescapeStr(str.slice(start, pos));\n\t        start = re.lastIndex;\n\t        re = _bp[6 + (isexpr ^= 1)];\n\t        re.lastIndex = start;\n\t      }\n\t    }\n\t\n\t    if (str && start < str.length) {\n\t      unescapeStr(str.slice(start));\n\t    }\n\t\n\t    return parts\n\t\n\t    function unescapeStr (s) {\n\t      if (tmpl || isexpr) {\n\t        parts.push(s && s.replace(_bp[5], '$1'));\n\t      } else {\n\t        parts.push(s);\n\t      }\n\t    }\n\t\n\t    function skipBraces (s, ch, ix) {\n\t      var\n\t        match,\n\t        recch = FINDBRACES[ch];\n\t\n\t      recch.lastIndex = ix;\n\t      ix = 1;\n\t      while ((match = recch.exec(s))) {\n\t        if (match[1] &&\n\t          !(match[1] === ch ? ++ix : --ix)) { break }\n\t      }\n\t      return ix ? s.length : recch.lastIndex\n\t    }\n\t  };\n\t\n\t  _brackets.hasExpr = function hasExpr (str) {\n\t    return _cache[4].test(str)\n\t  };\n\t\n\t  _brackets.loopKeys = function loopKeys (expr) {\n\t    var m = expr.match(_cache[9]);\n\t\n\t    return m\n\t      ? { key: m[1], pos: m[2], val: _cache[0] + m[3].trim() + _cache[1] }\n\t      : { val: expr.trim() }\n\t  };\n\t\n\t  _brackets.array = function array (pair) {\n\t    return pair ? _create(pair) : _cache\n\t  };\n\t\n\t  function _reset (pair) {\n\t    if ((pair || (pair = DEFAULT)) !== _cache[8]) {\n\t      _cache = _create(pair);\n\t      _regex = pair === DEFAULT ? _loopback : _rewrite;\n\t      _cache[9] = _regex(_pairs[9]);\n\t    }\n\t    cachedBrackets = pair;\n\t  }\n\t\n\t  function _setSettings (o) {\n\t    var b;\n\t\n\t    o = o || {};\n\t    b = o.brackets;\n\t    Object.defineProperty(o, 'brackets', {\n\t      set: _reset,\n\t      get: function () { return cachedBrackets },\n\t      enumerable: true\n\t    });\n\t    _settings = o;\n\t    _reset(b);\n\t  }\n\t\n\t  Object.defineProperty(_brackets, 'settings', {\n\t    set: _setSettings,\n\t    get: function () { return _settings }\n\t  });\n\t\n\t  /* istanbul ignore next: in the browser riot is always in the scope */\n\t  _brackets.settings = typeof riot !== 'undefined' && riot.settings || {};\n\t  _brackets.set = _reset;\n\t\n\t  _brackets.R_STRINGS = R_STRINGS;\n\t  _brackets.R_MLCOMMS = R_MLCOMMS;\n\t  _brackets.S_QBLOCKS = S_QBLOCKS;\n\t\n\t  return _brackets\n\t\n\t})();\n\t\n\t/**\n\t * @module tmpl\n\t *\n\t * tmpl          - Root function, returns the template value, render with data\n\t * tmpl.hasExpr  - Test the existence of a expression inside a string\n\t * tmpl.loopKeys - Get the keys for an 'each' loop (used by `_each`)\n\t */\n\t\n\tvar tmpl = (function () {\n\t\n\t  var _cache = {};\n\t\n\t  function _tmpl (str, data) {\n\t    if (!str) { return str }\n\t\n\t    return (_cache[str] || (_cache[str] = _create(str))).call(data, _logErr)\n\t  }\n\t\n\t  _tmpl.hasExpr = brackets.hasExpr;\n\t\n\t  _tmpl.loopKeys = brackets.loopKeys;\n\t\n\t  // istanbul ignore next\n\t  _tmpl.clearCache = function () { _cache = {}; };\n\t\n\t  _tmpl.errorHandler = null;\n\t\n\t  function _logErr (err, ctx) {\n\t\n\t    err.riotData = {\n\t      tagName: ctx && ctx.root && ctx.root.tagName,\n\t      _riot_id: ctx && ctx._riot_id  //eslint-disable-line camelcase\n\t    };\n\t\n\t    if (_tmpl.errorHandler) { _tmpl.errorHandler(err); }\n\t\n\t    if (\n\t      typeof console !== 'undefined' &&\n\t      typeof console.error === 'function'\n\t    ) {\n\t      if (err.riotData.tagName) {\n\t        console.error('Riot template error thrown in the <%s> tag', err.riotData.tagName);\n\t      }\n\t      console.error(err);\n\t    }\n\t  }\n\t\n\t  function _create (str) {\n\t    var expr = _getTmpl(str);\n\t\n\t    if (expr.slice(0, 11) !== 'try{return ') { expr = 'return ' + expr; }\n\t\n\t    return new Function('E', expr + ';')    // eslint-disable-line no-new-func\n\t  }\n\t\n\t  var\n\t    CH_IDEXPR = String.fromCharCode(0x2057),\n\t    RE_CSNAME = /^(?:(-?[_A-Za-z\\xA0-\\xFF][-\\w\\xA0-\\xFF]*)|\\u2057(\\d+)~):/,\n\t    RE_QBLOCK = RegExp(brackets.S_QBLOCKS, 'g'),\n\t    RE_DQUOTE = /\\u2057/g,\n\t    RE_QBMARK = /\\u2057(\\d+)~/g;\n\t\n\t  function _getTmpl (str) {\n\t    var\n\t      qstr = [],\n\t      expr,\n\t      parts = brackets.split(str.replace(RE_DQUOTE, '\"'), 1);\n\t\n\t    if (parts.length > 2 || parts[0]) {\n\t      var i, j, list = [];\n\t\n\t      for (i = j = 0; i < parts.length; ++i) {\n\t\n\t        expr = parts[i];\n\t\n\t        if (expr && (expr = i & 1\n\t\n\t            ? _parseExpr(expr, 1, qstr)\n\t\n\t            : '\"' + expr\n\t                .replace(/\\\\/g, '\\\\\\\\')\n\t                .replace(/\\r\\n?|\\n/g, '\\\\n')\n\t                .replace(/\"/g, '\\\\\"') +\n\t              '\"'\n\t\n\t          )) { list[j++] = expr; }\n\t\n\t      }\n\t\n\t      expr = j < 2 ? list[0]\n\t           : '[' + list.join(',') + '].join(\"\")';\n\t\n\t    } else {\n\t\n\t      expr = _parseExpr(parts[1], 0, qstr);\n\t    }\n\t\n\t    if (qstr[0]) {\n\t      expr = expr.replace(RE_QBMARK, function (_, pos) {\n\t        return qstr[pos]\n\t          .replace(/\\r/g, '\\\\r')\n\t          .replace(/\\n/g, '\\\\n')\n\t      });\n\t    }\n\t    return expr\n\t  }\n\t\n\t  var\n\t    RE_BREND = {\n\t      '(': /[()]/g,\n\t      '[': /[[\\]]/g,\n\t      '{': /[{}]/g\n\t    };\n\t\n\t  function _parseExpr (expr, asText, qstr) {\n\t\n\t    expr = expr\n\t          .replace(RE_QBLOCK, function (s, div) {\n\t            return s.length > 2 && !div ? CH_IDEXPR + (qstr.push(s) - 1) + '~' : s\n\t          })\n\t          .replace(/\\s+/g, ' ').trim()\n\t          .replace(/\\ ?([[\\({},?\\.:])\\ ?/g, '$1');\n\t\n\t    if (expr) {\n\t      var\n\t        list = [],\n\t        cnt = 0,\n\t        match;\n\t\n\t      while (expr &&\n\t            (match = expr.match(RE_CSNAME)) &&\n\t            !match.index\n\t        ) {\n\t        var\n\t          key,\n\t          jsb,\n\t          re = /,|([[{(])|$/g;\n\t\n\t        expr = RegExp.rightContext;\n\t        key  = match[2] ? qstr[match[2]].slice(1, -1).trim().replace(/\\s+/g, ' ') : match[1];\n\t\n\t        while (jsb = (match = re.exec(expr))[1]) { skipBraces(jsb, re); }\n\t\n\t        jsb  = expr.slice(0, match.index);\n\t        expr = RegExp.rightContext;\n\t\n\t        list[cnt++] = _wrapExpr(jsb, 1, key);\n\t      }\n\t\n\t      expr = !cnt ? _wrapExpr(expr, asText)\n\t           : cnt > 1 ? '[' + list.join(',') + '].join(\" \").trim()' : list[0];\n\t    }\n\t    return expr\n\t\n\t    function skipBraces (ch, re) {\n\t      var\n\t        mm,\n\t        lv = 1,\n\t        ir = RE_BREND[ch];\n\t\n\t      ir.lastIndex = re.lastIndex;\n\t      while (mm = ir.exec(expr)) {\n\t        if (mm[0] === ch) { ++lv; }\n\t        else if (!--lv) { break }\n\t      }\n\t      re.lastIndex = lv ? expr.length : ir.lastIndex;\n\t    }\n\t  }\n\t\n\t  // istanbul ignore next: not both\n\t  var // eslint-disable-next-line max-len\n\t    JS_CONTEXT = '\"in this?this:' + (typeof window !== 'object' ? 'global' : 'window') + ').',\n\t    JS_VARNAME = /[,{][\\$\\w]+(?=:)|(^ *|[^$\\w\\.{])(?!(?:typeof|true|false|null|undefined|in|instanceof|is(?:Finite|NaN)|void|NaN|new|Date|RegExp|Math)(?![$\\w]))([$_A-Za-z][$\\w]*)/g,\n\t    JS_NOPROPS = /^(?=(\\.[$\\w]+))\\1(?:[^.[(]|$)/;\n\t\n\t  function _wrapExpr (expr, asText, key) {\n\t    var tb;\n\t\n\t    expr = expr.replace(JS_VARNAME, function (match, p, mvar, pos, s) {\n\t      if (mvar) {\n\t        pos = tb ? 0 : pos + match.length;\n\t\n\t        if (mvar !== 'this' && mvar !== 'global' && mvar !== 'window') {\n\t          match = p + '(\"' + mvar + JS_CONTEXT + mvar;\n\t          if (pos) { tb = (s = s[pos]) === '.' || s === '(' || s === '['; }\n\t        } else if (pos) {\n\t          tb = !JS_NOPROPS.test(s.slice(pos));\n\t        }\n\t      }\n\t      return match\n\t    });\n\t\n\t    if (tb) {\n\t      expr = 'try{return ' + expr + '}catch(e){E(e,this)}';\n\t    }\n\t\n\t    if (key) {\n\t\n\t      expr = (tb\n\t          ? 'function(){' + expr + '}.call(this)' : '(' + expr + ')'\n\t        ) + '?\"' + key + '\":\"\"';\n\t\n\t    } else if (asText) {\n\t\n\t      expr = 'function(v){' + (tb\n\t          ? expr.replace('return ', 'v=') : 'v=(' + expr + ')'\n\t        ) + ';return v||v===0?v:\"\"}.call(this)';\n\t    }\n\t\n\t    return expr\n\t  }\n\t\n\t  _tmpl.version = brackets.version = 'v3.0.0';\n\t\n\t  return _tmpl\n\t\n\t})();\n\t\n\t/**\n\t * Specialized function for looping an array-like collection with `each={}`\n\t * @param   { Array } list - collection of items\n\t * @param   {Function} fn - callback function\n\t * @returns { Array } the array looped\n\t */\n\tfunction each(list, fn) {\n\t  var len = list ? list.length : 0;\n\t\n\t  for (var i = 0, el; i < len; ++i) {\n\t    el = list[i];\n\t    // return false -> current item was removed by fn during the loop\n\t    if (fn(el, i) === false)\n\t      { i--; }\n\t  }\n\t  return list\n\t}\n\t\n\t/**\n\t * Check whether an array contains an item\n\t * @param   { Array } array - target array\n\t * @param   { * } item - item to test\n\t * @returns { Boolean } -\n\t */\n\tfunction contains(array, item) {\n\t  return ~array.indexOf(item)\n\t}\n\t\n\t/**\n\t * Convert a string containing dashes to camel case\n\t * @param   { String } str - input string\n\t * @returns { String } my-string -> myString\n\t */\n\tfunction toCamel(str) {\n\t  return str.replace(/-(\\w)/g, function (_, c) { return c.toUpperCase(); })\n\t}\n\t\n\t/**\n\t * Faster String startsWith alternative\n\t * @param   { String } str - source string\n\t * @param   { String } value - test string\n\t * @returns { Boolean } -\n\t */\n\tfunction startsWith(str, value) {\n\t  return str.slice(0, value.length) === value\n\t}\n\t\n\t/**\n\t * Helper function to set an immutable property\n\t * @param   { Object } el - object where the new property will be set\n\t * @param   { String } key - object key where the new property will be stored\n\t * @param   { * } value - value of the new property\n\t * @param   { Object } options - set the propery overriding the default options\n\t * @returns { Object } - the initial object\n\t */\n\tfunction defineProperty(el, key, value, options) {\n\t  Object.defineProperty(el, key, extend({\n\t    value: value,\n\t    enumerable: false,\n\t    writable: false,\n\t    configurable: true\n\t  }, options));\n\t  return el\n\t}\n\t\n\t/**\n\t * Extend any object with other properties\n\t * @param   { Object } src - source object\n\t * @returns { Object } the resulting extended object\n\t *\n\t * var obj = { foo: 'baz' }\n\t * extend(obj, {bar: 'bar', foo: 'bar'})\n\t * console.log(obj) => {bar: 'bar', foo: 'bar'}\n\t *\n\t */\n\tfunction extend(src) {\n\t  var obj, args = arguments;\n\t  for (var i = 1; i < args.length; ++i) {\n\t    if (obj = args[i]) {\n\t      for (var key in obj) {\n\t        // check if this property of the source object could be overridden\n\t        if (isWritable(src, key))\n\t          { src[key] = obj[key]; }\n\t      }\n\t    }\n\t  }\n\t  return src\n\t}\n\t\n\tvar misc = Object.freeze({\n\t\teach: each,\n\t\tcontains: contains,\n\t\ttoCamel: toCamel,\n\t\tstartsWith: startsWith,\n\t\tdefineProperty: defineProperty,\n\t\textend: extend\n\t});\n\t\n\tvar observable = function(el) {\n\t\n\t  /**\n\t   * Extend the original object or create a new empty one\n\t   * @type { Object }\n\t   */\n\t\n\t  el = el || {};\n\t\n\t  /**\n\t   * Private variables\n\t   */\n\t  var callbacks = {},\n\t    slice = Array.prototype.slice;\n\t\n\t  /**\n\t   * Public Api\n\t   */\n\t\n\t  // extend the el object adding the observable methods\n\t  Object.defineProperties(el, {\n\t    /**\n\t     * Listen to the given `event` ands\n\t     * execute the `callback` each time an event is triggered.\n\t     * @param  { String } event - event id\n\t     * @param  { Function } fn - callback function\n\t     * @returns { Object } el\n\t     */\n\t    on: {\n\t      value: function(event, fn) {\n\t        if (typeof fn == 'function')\n\t          { (callbacks[event] = callbacks[event] || []).push(fn); }\n\t        return el\n\t      },\n\t      enumerable: false,\n\t      writable: false,\n\t      configurable: false\n\t    },\n\t\n\t    /**\n\t     * Removes the given `event` listeners\n\t     * @param   { String } event - event id\n\t     * @param   { Function } fn - callback function\n\t     * @returns { Object } el\n\t     */\n\t    off: {\n\t      value: function(event, fn) {\n\t        if (event == '*' && !fn) { callbacks = {}; }\n\t        else {\n\t          if (fn) {\n\t            var arr = callbacks[event];\n\t            for (var i = 0, cb; cb = arr && arr[i]; ++i) {\n\t              if (cb == fn) { arr.splice(i--, 1); }\n\t            }\n\t          } else { delete callbacks[event]; }\n\t        }\n\t        return el\n\t      },\n\t      enumerable: false,\n\t      writable: false,\n\t      configurable: false\n\t    },\n\t\n\t    /**\n\t     * Listen to the given `event` and\n\t     * execute the `callback` at most once\n\t     * @param   { String } event - event id\n\t     * @param   { Function } fn - callback function\n\t     * @returns { Object } el\n\t     */\n\t    one: {\n\t      value: function(event, fn) {\n\t        function on() {\n\t          el.off(event, on);\n\t          fn.apply(el, arguments);\n\t        }\n\t        return el.on(event, on)\n\t      },\n\t      enumerable: false,\n\t      writable: false,\n\t      configurable: false\n\t    },\n\t\n\t    /**\n\t     * Execute all callback functions that listen to\n\t     * the given `event`\n\t     * @param   { String } event - event id\n\t     * @returns { Object } el\n\t     */\n\t    trigger: {\n\t      value: function(event) {\n\t        var arguments$1 = arguments;\n\t\n\t\n\t        // getting the arguments\n\t        var arglen = arguments.length - 1,\n\t          args = new Array(arglen),\n\t          fns,\n\t          fn,\n\t          i;\n\t\n\t        for (i = 0; i < arglen; i++) {\n\t          args[i] = arguments$1[i + 1]; // skip first argument\n\t        }\n\t\n\t        fns = slice.call(callbacks[event] || [], 0);\n\t\n\t        for (i = 0; fn = fns[i]; ++i) {\n\t          fn.apply(el, args);\n\t        }\n\t\n\t        if (callbacks['*'] && event != '*')\n\t          { el.trigger.apply(el, ['*', event].concat(args)); }\n\t\n\t        return el\n\t      },\n\t      enumerable: false,\n\t      writable: false,\n\t      configurable: false\n\t    }\n\t  });\n\t\n\t  return el\n\t\n\t};\n\t\n\tvar EVENTS_PREFIX_REGEX = /^on/;\n\t\n\t/**\n\t * Trigger DOM events\n\t * @param   { HTMLElement } dom - dom element target of the event\n\t * @param   { Function } handler - user function\n\t * @param   { Object } e - event object\n\t */\n\tfunction handleEvent(dom, handler, e) {\n\t  var ptag = this._parent,\n\t    item = this._item;\n\t\n\t  if (!item)\n\t    { while (ptag && !item) {\n\t      item = ptag._item;\n\t      ptag = ptag._parent;\n\t    } }\n\t\n\t  // override the event properties\n\t  if (isWritable(e, 'currentTarget')) { e.currentTarget = dom; }\n\t  if (isWritable(e, 'target')) { e.target = e.srcElement; }\n\t  if (isWritable(e, 'which')) { e.which = e.charCode || e.keyCode; }\n\t\n\t  e.item = item;\n\t\n\t  handler.call(this, e);\n\t\n\t  if (!e.preventUpdate) {\n\t    var p = getImmediateCustomParentTag(this);\n\t    // fixes #2083\n\t    if (p.isMounted) { p.update(); }\n\t  }\n\t}\n\t\n\t/**\n\t * Attach an event to a DOM node\n\t * @param { String } name - event name\n\t * @param { Function } handler - event callback\n\t * @param { Object } dom - dom node\n\t * @param { Tag } tag - tag instance\n\t */\n\tfunction setEventHandler(name, handler, dom, tag) {\n\t  var eventName,\n\t    cb = handleEvent.bind(tag, dom, handler);\n\t\n\t  if (!dom.addEventListener) {\n\t    dom[name] = cb;\n\t    return\n\t  }\n\t\n\t  // avoid to bind twice the same event\n\t  dom[name] = null;\n\t\n\t  // normalize event name\n\t  eventName = name.replace(EVENTS_PREFIX_REGEX, '');\n\t\n\t  // cache the callback directly on the DOM node\n\t  if (!dom._riotEvents) { dom._riotEvents = {}; }\n\t\n\t  if (dom._riotEvents[name])\n\t    { dom.removeEventListener(eventName, dom._riotEvents[name]); }\n\t\n\t  dom._riotEvents[name] = cb;\n\t  dom.addEventListener(eventName, cb, false);\n\t}\n\t\n\t/**\n\t * Update dynamically created data-is tags with changing expressions\n\t * @param { Object } expr - expression tag and expression info\n\t * @param { Tag } parent - parent for tag creation\n\t */\n\tfunction updateDataIs(expr, parent) {\n\t  var tagName = tmpl(expr.value, parent),\n\t    conf;\n\t\n\t  if (expr.tag && expr.tagName === tagName) {\n\t    expr.tag.update();\n\t    return\n\t  }\n\t\n\t  // sync _parent to accommodate changing tagnames\n\t  if (expr.tag) {\n\t    var delName = expr.value,\n\t      tags = expr.tag._parent.tags;\n\t\n\t    setAttr(expr.tag.root, RIOT_TAG_IS, tagName); // update for css\n\t    arrayishRemove(tags, delName, expr.tag);\n\t  }\n\t\n\t  expr.impl = __TAG_IMPL[tagName];\n\t  conf = {root: expr.dom, parent: parent, hasImpl: true, tagName: tagName};\n\t  expr.tag = initChildTag(expr.impl, conf, expr.dom.innerHTML, parent);\n\t  expr.tagName = tagName;\n\t  expr.tag.mount();\n\t  expr.tag.update();\n\t\n\t  // parent is the placeholder tag, not the dynamic tag so clean up\n\t  parent.on('unmount', function () {\n\t    var delName = expr.tag.opts.dataIs,\n\t      tags = expr.tag.parent.tags,\n\t      _tags = expr.tag._parent.tags;\n\t    arrayishRemove(tags, delName, expr.tag);\n\t    arrayishRemove(_tags, delName, expr.tag);\n\t    expr.tag.unmount();\n\t  });\n\t}\n\t\n\t/**\n\t * Update on single tag expression\n\t * @this Tag\n\t * @param { Object } expr - expression logic\n\t * @returns { undefined }\n\t */\n\tfunction updateExpression(expr) {\n\t  var dom = expr.dom,\n\t    attrName = expr.attr,\n\t    value = tmpl(expr.expr, this),\n\t    isValueAttr = attrName === 'riot-value',\n\t    isVirtual = expr.root && expr.root.tagName === 'VIRTUAL',\n\t    parent = dom && (expr.parent || dom.parentNode),\n\t    old;\n\t\n\t  if (expr.bool)\n\t    { value = value ? attrName : false; }\n\t  else if (isUndefined(value) || value === null)\n\t    { value = ''; }\n\t\n\t  if (expr._riot_id) { // if it's a tag\n\t    if (expr.isMounted) {\n\t      expr.update();\n\t\n\t    // if it hasn't been mounted yet, do that now.\n\t    } else {\n\t      expr.mount();\n\t\n\t      if (isVirtual) {\n\t        var frag = document.createDocumentFragment();\n\t        makeVirtual.call(expr, frag);\n\t        expr.root.parentElement.replaceChild(frag, expr.root);\n\t      }\n\t    }\n\t    return\n\t  }\n\t\n\t  old = expr.value;\n\t  expr.value = value;\n\t\n\t  if (expr.update) {\n\t    expr.update();\n\t    return\n\t  }\n\t\n\t  if (old === value) { return }\n\t  if (expr.isRtag && value) { return updateDataIs(expr, this) }\n\t  // no change, so nothing more to do\n\t  if (isValueAttr && dom.value === value) { return }\n\t\n\t  // textarea and text nodes have no attribute name\n\t  if (!attrName) {\n\t    // about #815 w/o replace: the browser converts the value to a string,\n\t    // the comparison by \"==\" does too, but not in the server\n\t    value += '';\n\t    // test for parent avoids error with invalid assignment to nodeValue\n\t    if (parent) {\n\t      // cache the parent node because somehow it will become null on IE\n\t      // on the next iteration\n\t      expr.parent = parent;\n\t      if (parent.tagName === 'TEXTAREA') {\n\t        parent.value = value;                    // #1113\n\t        if (!IE_VERSION) { dom.nodeValue = value; }  // #1625 IE throws here, nodeValue\n\t      }                                         // will be available on 'updated'\n\t      else { dom.nodeValue = value; }\n\t    }\n\t    return\n\t  }\n\t\n\t  // remove original attribute\n\t  if (!expr.isAttrRemoved || !value) {\n\t    remAttr(dom, attrName);\n\t    expr.isAttrRemoved = true;\n\t  }\n\t\n\t  // event handler\n\t  if (isFunction(value)) {\n\t    setEventHandler(attrName, value, dom, this);\n\t  // show / hide\n\t  } else if (/^(show|hide)$/.test(attrName)) {\n\t    if (attrName === 'hide') { value = !value; }\n\t    dom.style.display = value ? '' : 'none';\n\t  // field value\n\t  } else if (isValueAttr) {\n\t    dom.value = value;\n\t  // <img src=\"{ expr }\">\n\t  } else if (startsWith(attrName, RIOT_PREFIX) && attrName !== RIOT_TAG_IS) {\n\t    if (value != null)\n\t      { setAttr(dom, attrName.slice(RIOT_PREFIX.length), value); }\n\t  } else {\n\t    // <select> <option selected={true}> </select>\n\t    if (attrName === 'selected' && parent && /^(SELECT|OPTGROUP)$/.test(parent.tagName) && value != null) {\n\t      parent.value = dom.value;\n\t    } if (expr.bool) {\n\t      dom[attrName] = value;\n\t      if (!value) { return }\n\t    } if (value === 0 || value && typeof value !== T_OBJECT) {\n\t      setAttr(dom, attrName, value);\n\t    }\n\t  }\n\t}\n\t\n\t/**\n\t * Update all the expressions in a Tag instance\n\t * @this Tag\n\t * @param { Array } expressions - expression that must be re evaluated\n\t */\n\tfunction update$1$1(expressions) {\n\t  each(expressions, updateExpression.bind(this));\n\t}\n\t\n\tvar IfExpr = {\n\t  init: function init(dom, parentTag, expr) {\n\t    remAttr(dom, 'if');\n\t    this.parentTag = parentTag;\n\t    this.expr = expr;\n\t    this.stub = document.createTextNode('');\n\t    this.pristine = dom;\n\t\n\t    var p = dom.parentNode;\n\t    p.insertBefore(this.stub, dom);\n\t    p.removeChild(dom);\n\t\n\t    return this\n\t  },\n\t  update: function update$1() {\n\t    var newValue = tmpl(this.expr, this.parentTag);\n\t\n\t    if (newValue && !this.current) { // insert\n\t      this.current = this.pristine.cloneNode(true);\n\t      this.stub.parentNode.insertBefore(this.current, this.stub);\n\t\n\t      this.expressions = [];\n\t      parseExpressions.apply(this.parentTag, [this.current, this.expressions, true]);\n\t    } else if (!newValue && this.current) { // remove\n\t      unmountAll(this.expressions);\n\t      if (this.current._tag) {\n\t        this.current._tag.unmount();\n\t      } else if (this.current.parentNode)\n\t        { this.current.parentNode.removeChild(this.current); }\n\t      this.current = null;\n\t      this.expressions = [];\n\t    }\n\t\n\t    if (newValue) { update$1$1.call(this.parentTag, this.expressions); }\n\t  },\n\t  unmount: function unmount() {\n\t    unmountAll(this.expressions || []);\n\t    delete this.pristine;\n\t    delete this.parentNode;\n\t    delete this.stub;\n\t  }\n\t};\n\t\n\tvar RefExpr = {\n\t  init: function init(dom, attrName, attrValue, parent) {\n\t    this.dom = dom;\n\t    this.attr = attrName;\n\t    this.rawValue = attrValue;\n\t    this.parent = parent;\n\t    this.hasExp = tmpl.hasExpr(attrValue);\n\t    this.firstRun = true;\n\t\n\t    return this\n\t  },\n\t  update: function update() {\n\t    var value = this.rawValue;\n\t    if (this.hasExp)\n\t      { value = tmpl(this.rawValue, this.parent); }\n\t\n\t    // if nothing changed, we're done\n\t    if (!this.firstRun && value === this.value) { return }\n\t\n\t    var customParent = this.parent && getImmediateCustomParentTag(this.parent);\n\t\n\t    // if the referenced element is a custom tag, then we set the tag itself, rather than DOM\n\t    var tagOrDom = this.tag || this.dom;\n\t\n\t    // the name changed, so we need to remove it from the old key (if present)\n\t    if (!isBlank(this.value) && customParent)\n\t      { arrayishRemove(customParent.refs, this.value, tagOrDom); }\n\t\n\t    if (isBlank(value)) {\n\t      // if the value is blank, we remove it\n\t      remAttr(this.dom, this.attr);\n\t    } else {\n\t      // add it to the refs of parent tag (this behavior was changed >=3.0)\n\t      if (customParent) { arrayishAdd(customParent.refs, value, tagOrDom); }\n\t      // set the actual DOM attr\n\t      setAttr(this.dom, this.attr, value);\n\t    }\n\t    this.value = value;\n\t    this.firstRun = false;\n\t  },\n\t  unmount: function unmount() {\n\t    var tagOrDom = this.tag || this.dom;\n\t    var customParent = this.parent && getImmediateCustomParentTag(this.parent);\n\t    if (!isBlank(this.value) && customParent)\n\t      { arrayishRemove(customParent.refs, this.value, tagOrDom); }\n\t    delete this.dom;\n\t    delete this.parent;\n\t  }\n\t};\n\t\n\t/**\n\t * Convert the item looped into an object used to extend the child tag properties\n\t * @param   { Object } expr - object containing the keys used to extend the children tags\n\t * @param   { * } key - value to assign to the new object returned\n\t * @param   { * } val - value containing the position of the item in the array\n\t * @param   { Object } base - prototype object for the new item\n\t * @returns { Object } - new object containing the values of the original item\n\t *\n\t * The variables 'key' and 'val' are arbitrary.\n\t * They depend on the collection type looped (Array, Object)\n\t * and on the expression used on the each tag\n\t *\n\t */\n\tfunction mkitem(expr, key, val, base) {\n\t  var item = base ? Object.create(base) : {};\n\t  item[expr.key] = key;\n\t  if (expr.pos) { item[expr.pos] = val; }\n\t  return item\n\t}\n\t\n\t/**\n\t * Unmount the redundant tags\n\t * @param   { Array } items - array containing the current items to loop\n\t * @param   { Array } tags - array containing all the children tags\n\t * @param   { String } tagName - key used to identify the type of tag\n\t * @param   { Object } parent - parent tag to remove the child from\n\t */\n\tfunction unmountRedundant(items, tags, tagName, parent) {\n\t\n\t  var i = tags.length,\n\t    j = items.length,\n\t    t;\n\t\n\t  while (i > j) {\n\t    t = tags[--i];\n\t    tags.splice(i, 1);\n\t    t.unmount();\n\t    arrayishRemove(parent.tags, tagName, t, true);\n\t  }\n\t}\n\t\n\t/**\n\t * Move the nested custom tags in non custom loop tags\n\t * @this Tag\n\t * @param   { Number } i - current position of the loop tag\n\t */\n\tfunction moveNestedTags(i) {\n\t  var this$1 = this;\n\t\n\t  each(Object.keys(this.tags), function (tagName) {\n\t    var tag = this$1.tags[tagName];\n\t    if (isArray(tag))\n\t      { each(tag, function (t) {\n\t        moveChildTag.apply(t, [tagName, i]);\n\t      }); }\n\t    else\n\t      { moveChildTag.apply(tag, [tagName, i]); }\n\t  });\n\t}\n\t\n\t/**\n\t * Move a child tag\n\t * @this Tag\n\t * @param   { HTMLElement } root - dom node containing all the loop children\n\t * @param   { Tag } nextTag - instance of the next tag preceding the one we want to move\n\t * @param   { Boolean } isVirtual - is it a virtual tag?\n\t */\n\tfunction move(root, nextTag, isVirtual) {\n\t  if (isVirtual)\n\t    { moveVirtual.apply(this, [root, nextTag]); }\n\t  else\n\t    { safeInsert(root, this.root, nextTag.root); }\n\t}\n\t\n\t/**\n\t * Insert and mount a child tag\n\t * @this Tag\n\t * @param   { HTMLElement } root - dom node containing all the loop children\n\t * @param   { Tag } nextTag - instance of the next tag preceding the one we want to insert\n\t * @param   { Boolean } isVirtual - is it a virtual tag?\n\t */\n\tfunction insert(root, nextTag, isVirtual) {\n\t  if (isVirtual)\n\t    { makeVirtual.apply(this, [root, nextTag]); }\n\t  else\n\t    { safeInsert(root, this.root, nextTag.root); }\n\t}\n\t\n\t/**\n\t * Append a new tag into the DOM\n\t * @this Tag\n\t * @param   { HTMLElement } root - dom node containing all the loop children\n\t * @param   { Boolean } isVirtual - is it a virtual tag?\n\t */\n\tfunction append(root, isVirtual) {\n\t  if (isVirtual)\n\t    { makeVirtual.call(this, root); }\n\t  else\n\t    { root.appendChild(this.root); }\n\t}\n\t\n\t/**\n\t * Manage tags having the 'each'\n\t * @param   { HTMLElement } dom - DOM node we need to loop\n\t * @param   { Tag } parent - parent tag instance where the dom node is contained\n\t * @param   { String } expr - string contained in the 'each' attribute\n\t * @returns { Object } expression object for this each loop\n\t */\n\tfunction _each(dom, parent, expr) {\n\t\n\t  // remove the each property from the original tag\n\t  remAttr(dom, 'each');\n\t\n\t  var mustReorder = typeof getAttr(dom, 'no-reorder') !== T_STRING || remAttr(dom, 'no-reorder'),\n\t    tagName = getTagName(dom),\n\t    impl = __TAG_IMPL[tagName] || { tmpl: getOuterHTML(dom) },\n\t    useRoot = RE_SPECIAL_TAGS.test(tagName),\n\t    root = dom.parentNode,\n\t    ref = createDOMPlaceholder(),\n\t    child = getTag(dom),\n\t    ifExpr = getAttr(dom, 'if'),\n\t    tags = [],\n\t    oldItems = [],\n\t    hasKeys,\n\t    isLoop = true,\n\t    isAnonymous = !__TAG_IMPL[tagName],\n\t    isVirtual = dom.tagName === 'VIRTUAL';\n\t\n\t  // parse the each expression\n\t  expr = tmpl.loopKeys(expr);\n\t  expr.isLoop = true;\n\t\n\t  if (ifExpr) { remAttr(dom, 'if'); }\n\t\n\t  // insert a marked where the loop tags will be injected\n\t  root.insertBefore(ref, dom);\n\t  root.removeChild(dom);\n\t\n\t  expr.update = function updateEach() {\n\t\n\t    // get the new items collection\n\t    var items = tmpl(expr.val, parent),\n\t      parentNode,\n\t      frag,\n\t      placeholder;\n\t\n\t\n\t    root = ref.parentNode;\n\t\n\t    if (parentNode) {\n\t      placeholder = createDOMPlaceholder('');\n\t      parentNode.insertBefore(placeholder, root);\n\t      parentNode.removeChild(root);\n\t    } else {\n\t      frag = createFrag();\n\t    }\n\t\n\t    // object loop. any changes cause full redraw\n\t    if (!isArray(items)) {\n\t      hasKeys = items || false;\n\t      items = hasKeys ?\n\t        Object.keys(items).map(function (key) {\n\t          return mkitem(expr, items[key], key)\n\t        }) : [];\n\t    } else {\n\t      hasKeys = false;\n\t    }\n\t\n\t    if (ifExpr) {\n\t      items = items.filter(function(item, i) {\n\t        if (expr.key) {\n\t          return !!tmpl(ifExpr, mkitem(expr, item, i, parent))\n\t        }\n\t        // in case it's not a keyed loop\n\t        // we test the validity of the if expression against\n\t        // the item and the parent\n\t        return !!tmpl(ifExpr, parent) || !!tmpl(ifExpr, item)\n\t      });\n\t    }\n\t\n\t    // loop all the new items\n\t    each(items, function(item, i) {\n\t      // reorder only if the items are objects\n\t      var\n\t        _mustReorder = mustReorder && typeof item === T_OBJECT && !hasKeys,\n\t        oldPos = oldItems.indexOf(item),\n\t        pos = ~oldPos && _mustReorder ? oldPos : i,\n\t        // does a tag exist in this position?\n\t        tag = tags[pos];\n\t\n\t      item = !hasKeys && expr.key ? mkitem(expr, item, i) : item;\n\t\n\t      // new tag\n\t      if (\n\t        !_mustReorder && !tag // with no-reorder we just update the old tags\n\t        ||\n\t        _mustReorder && !~oldPos // by default we always try to reorder the DOM elements\n\t      ) {\n\t\n\t        var mustAppend = i === tags.length;\n\t\n\t        tag = new Tag$$1(impl, {\n\t          parent: parent,\n\t          isLoop: isLoop,\n\t          isAnonymous: isAnonymous,\n\t          root: useRoot ? root : dom.cloneNode(),\n\t          item: item\n\t        }, dom.innerHTML);\n\t\n\t        // mount the tag\n\t        tag.mount();\n\t\n\t        if (mustAppend)\n\t          { append.apply(tag, [frag || root, isVirtual]); }\n\t        else\n\t          { insert.apply(tag, [root, tags[i], isVirtual]); }\n\t\n\t        if (!mustAppend) { oldItems.splice(i, 0, item); }\n\t        tags.splice(i, 0, tag);\n\t        if (child) { arrayishAdd(parent.tags, tagName, tag, true); }\n\t        pos = i; // handled here so no move\n\t      } else { tag.update(item); }\n\t\n\t      // reorder the tag if it's not located in its previous position\n\t      if (pos !== i && _mustReorder) {\n\t        // #closes 2040\n\t        if (contains(items, oldItems[i])) {\n\t          move.apply(tag, [root, tags[i], isVirtual]);\n\t        }\n\t        // update the position attribute if it exists\n\t        if (expr.pos) { tag[expr.pos] = i; }\n\t        // move the old tag instance\n\t        tags.splice(i, 0, tags.splice(pos, 1)[0]);\n\t        // move the old item\n\t        oldItems.splice(i, 0, oldItems.splice(pos, 1)[0]);\n\t        // if the loop tags are not custom\n\t        // we need to move all their custom tags into the right position\n\t        if (!child && tag.tags) { moveNestedTags.call(tag, i); }\n\t      }\n\t\n\t      // cache the original item to use it in the events bound to this node\n\t      // and its children\n\t      tag._item = item;\n\t      // cache the real parent tag internally\n\t      defineProperty(tag, '_parent', parent);\n\t    });\n\t\n\t    // remove the redundant tags\n\t    unmountRedundant(items, tags, tagName, parent);\n\t\n\t    // clone the items array\n\t    oldItems = items.slice();\n\t\n\t    if (frag) {\n\t      root.insertBefore(frag, ref);\n\t    } else {\n\t      parentNode.insertBefore(root, placeholder);\n\t      parentNode.removeChild(placeholder);\n\t    }\n\t\n\t  };\n\t\n\t  expr.unmount = function() {\n\t    each(tags, function(t) { t.unmount(); });\n\t  };\n\t\n\t  return expr\n\t}\n\t\n\t/**\n\t * Walk the tag DOM to detect the expressions to evaluate\n\t * @this Tag\n\t * @param   { HTMLElement } root - root tag where we will start digging the expressions\n\t * @param   { Array } expressions - empty array where the expressions will be added\n\t * @param   { Boolean } mustIncludeRoot - flag to decide whether the root must be parsed as well\n\t * @returns { Object } an object containing the root noode and the dom tree\n\t */\n\tfunction parseExpressions(root, expressions, mustIncludeRoot) {\n\t  var this$1 = this;\n\t\n\t  var tree = {parent: {children: expressions}};\n\t\n\t  walkNodes(root, function (dom, ctx) {\n\t    var type = dom.nodeType, parent = ctx.parent, attr, expr, tagImpl;\n\t    if (!mustIncludeRoot && dom === root) { return {parent: parent} }\n\t\n\t    // text node\n\t    if (type === 3 && dom.parentNode.tagName !== 'STYLE' && tmpl.hasExpr(dom.nodeValue))\n\t      { parent.children.push({dom: dom, expr: dom.nodeValue}); }\n\t\n\t    if (type !== 1) { return ctx } // not an element\n\t\n\t    // loop. each does it's own thing (for now)\n\t    if (attr = getAttr(dom, 'each')) {\n\t      parent.children.push(_each(dom, this$1, attr));\n\t      return false\n\t    }\n\t\n\t    // if-attrs become the new parent. Any following expressions (either on the current\n\t    // element, or below it) become children of this expression.\n\t    if (attr = getAttr(dom, 'if')) {\n\t      parent.children.push(Object.create(IfExpr).init(dom, this$1, attr));\n\t      return false\n\t    }\n\t\n\t    if (expr = getAttr(dom, RIOT_TAG_IS)) {\n\t      if (tmpl.hasExpr(expr)) {\n\t        parent.children.push({isRtag: true, expr: expr, dom: dom});\n\t        return false\n\t      }\n\t    }\n\t\n\t    // if this is a tag, stop traversing here.\n\t    // we ignore the root, since parseExpressions is called while we're mounting that root\n\t    tagImpl = getTag(dom);\n\t    if (tagImpl && (dom !== root || mustIncludeRoot)) {\n\t      var conf = {root: dom, parent: this$1, hasImpl: true};\n\t      parent.children.push(initChildTag(tagImpl, conf, dom.innerHTML, this$1));\n\t      return false\n\t    }\n\t\n\t    // attribute expressions\n\t    parseAttributes.apply(this$1, [dom, dom.attributes, function(attr, expr) {\n\t      if (!expr) { return }\n\t      parent.children.push(expr);\n\t    }]);\n\t\n\t    // whatever the parent is, all child elements get the same parent.\n\t    // If this element had an if-attr, that's the parent for all child elements\n\t    return {parent: parent}\n\t  }, tree);\n\t\n\t  return { tree: tree, root: root }\n\t}\n\t\n\t/**\n\t * Calls `fn` for every attribute on an element. If that attr has an expression,\n\t * it is also passed to fn.\n\t * @this Tag\n\t * @param   { HTMLElement } dom - dom node to parse\n\t * @param   { Array } attrs - array of attributes\n\t * @param   { Function } fn - callback to exec on any iteration\n\t */\n\tfunction parseAttributes(dom, attrs, fn) {\n\t  var this$1 = this;\n\t\n\t  each(attrs, function (attr) {\n\t    var name = attr.name, bool = isBoolAttr(name), expr;\n\t\n\t    if (~['ref', 'data-ref'].indexOf(name)) {\n\t      expr =  Object.create(RefExpr).init(dom, name, attr.value, this$1);\n\t    } else if (tmpl.hasExpr(attr.value)) {\n\t      expr = {dom: dom, expr: attr.value, attr: attr.name, bool: bool};\n\t    }\n\t\n\t    fn(attr, expr);\n\t  });\n\t}\n\t\n\t/*\n\t  Includes hacks needed for the Internet Explorer version 9 and below\n\t  See: http://kangax.github.io/compat-table/es5/#ie8\n\t       http://codeplanet.io/dropping-ie8/\n\t*/\n\t\n\tvar reHasYield  = /<yield\\b/i;\n\tvar reYieldAll  = /<yield\\s*(?:\\/>|>([\\S\\s]*?)<\\/yield\\s*>|>)/ig;\n\tvar reYieldSrc  = /<yield\\s+to=['\"]([^'\">]*)['\"]\\s*>([\\S\\s]*?)<\\/yield\\s*>/ig;\n\tvar reYieldDest = /<yield\\s+from=['\"]?([-\\w]+)['\"]?\\s*(?:\\/>|>([\\S\\s]*?)<\\/yield\\s*>)/ig;\n\tvar rootEls = { tr: 'tbody', th: 'tr', td: 'tr', col: 'colgroup' };\n\tvar tblTags = IE_VERSION && IE_VERSION < 10 ? RE_SPECIAL_TAGS : RE_SPECIAL_TAGS_NO_OPTION;\n\tvar GENERIC = 'div';\n\t\n\t\n\t/*\n\t  Creates the root element for table or select child elements:\n\t  tr/th/td/thead/tfoot/tbody/caption/col/colgroup/option/optgroup\n\t*/\n\tfunction specialTags(el, tmpl, tagName) {\n\t\n\t  var\n\t    select = tagName[0] === 'o',\n\t    parent = select ? 'select>' : 'table>';\n\t\n\t  // trim() is important here, this ensures we don't have artifacts,\n\t  // so we can check if we have only one element inside the parent\n\t  el.innerHTML = '<' + parent + tmpl.trim() + '</' + parent;\n\t  parent = el.firstChild;\n\t\n\t  // returns the immediate parent if tr/th/td/col is the only element, if not\n\t  // returns the whole tree, as this can include additional elements\n\t  if (select) {\n\t    parent.selectedIndex = -1;  // for IE9, compatible w/current riot behavior\n\t  } else {\n\t    // avoids insertion of cointainer inside container (ex: tbody inside tbody)\n\t    var tname = rootEls[tagName];\n\t    if (tname && parent.childElementCount === 1) { parent = $(tname, parent); }\n\t  }\n\t  return parent\n\t}\n\t\n\t/*\n\t  Replace the yield tag from any tag template with the innerHTML of the\n\t  original tag in the page\n\t*/\n\tfunction replaceYield(tmpl, html) {\n\t  // do nothing if no yield\n\t  if (!reHasYield.test(tmpl)) { return tmpl }\n\t\n\t  // be careful with #1343 - string on the source having `$1`\n\t  var src = {};\n\t\n\t  html = html && html.replace(reYieldSrc, function (_, ref, text) {\n\t    src[ref] = src[ref] || text;   // preserve first definition\n\t    return ''\n\t  }).trim();\n\t\n\t  return tmpl\n\t    .replace(reYieldDest, function (_, ref, def) {  // yield with from - to attrs\n\t      return src[ref] || def || ''\n\t    })\n\t    .replace(reYieldAll, function (_, def) {        // yield without any \"from\"\n\t      return html || def || ''\n\t    })\n\t}\n\t\n\t/**\n\t * Creates a DOM element to wrap the given content. Normally an `DIV`, but can be\n\t * also a `TABLE`, `SELECT`, `TBODY`, `TR`, or `COLGROUP` element.\n\t *\n\t * @param   { String } tmpl  - The template coming from the custom tag definition\n\t * @param   { String } html - HTML content that comes from the DOM element where you\n\t *           will mount the tag, mostly the original tag in the page\n\t * @param   { Boolean } checkSvg - flag needed to know if we need to force the svg rendering in case of loop nodes\n\t * @returns { HTMLElement } DOM element with _tmpl_ merged through `YIELD` with the _html_.\n\t */\n\tfunction mkdom(tmpl, html, checkSvg) {\n\t  var match   = tmpl && tmpl.match(/^\\s*<([-\\w]+)/),\n\t    tagName = match && match[1].toLowerCase(),\n\t    el = mkEl(GENERIC, checkSvg && isSVGTag(tagName));\n\t\n\t  // replace all the yield tags with the tag inner html\n\t  tmpl = replaceYield(tmpl, html);\n\t\n\t  /* istanbul ignore next */\n\t  if (tblTags.test(tagName))\n\t    { el = specialTags(el, tmpl, tagName); }\n\t  else\n\t    { setInnerHTML(el, tmpl); }\n\t\n\t  el.stub = true;\n\t\n\t  return el\n\t}\n\t\n\t/**\n\t * Another way to create a riot tag a bit more es6 friendly\n\t * @param { HTMLElement } el - tag DOM selector or DOM node/s\n\t * @param { Object } opts - tag logic\n\t * @returns { Tag } new riot tag instance\n\t */\n\tfunction Tag$1(el, opts) {\n\t  // get the tag properties from the class constructor\n\t  var ref = this;\n\t  var name = ref.name;\n\t  var tmpl = ref.tmpl;\n\t  var css = ref.css;\n\t  var attrs = ref.attrs;\n\t  var onCreate = ref.onCreate;\n\t  // register a new tag and cache the class prototype\n\t  if (!__TAG_IMPL[name]) {\n\t    tag$$1(name, tmpl, css, attrs, onCreate);\n\t    // cache the class constructor\n\t    __TAG_IMPL[name].class = this.constructor;\n\t  }\n\t\n\t  // mount the tag using the class instance\n\t  mountTo(el, name, opts, this);\n\t  // inject the component css\n\t  if (css) { styleManager.inject(); }\n\t\n\t  return this\n\t}\n\t\n\t/**\n\t * Create a new riot tag implementation\n\t * @param   { String }   name - name/id of the new riot tag\n\t * @param   { String }   tmpl - tag template\n\t * @param   { String }   css - custom tag css\n\t * @param   { String }   attrs - root tag attributes\n\t * @param   { Function } fn - user function\n\t * @returns { String } name/id of the tag just created\n\t */\n\tfunction tag$$1(name, tmpl, css, attrs, fn) {\n\t  if (isFunction(attrs)) {\n\t    fn = attrs;\n\t\n\t    if (/^[\\w\\-]+\\s?=/.test(css)) {\n\t      attrs = css;\n\t      css = '';\n\t    } else\n\t      { attrs = ''; }\n\t  }\n\t\n\t  if (css) {\n\t    if (isFunction(css))\n\t      { fn = css; }\n\t    else\n\t      { styleManager.add(css); }\n\t  }\n\t\n\t  name = name.toLowerCase();\n\t  __TAG_IMPL[name] = { name: name, tmpl: tmpl, attrs: attrs, fn: fn };\n\t\n\t  return name\n\t}\n\t\n\t/**\n\t * Create a new riot tag implementation (for use by the compiler)\n\t * @param   { String }   name - name/id of the new riot tag\n\t * @param   { String }   tmpl - tag template\n\t * @param   { String }   css - custom tag css\n\t * @param   { String }   attrs - root tag attributes\n\t * @param   { Function } fn - user function\n\t * @returns { String } name/id of the tag just created\n\t */\n\tfunction tag2$$1(name, tmpl, css, attrs, fn) {\n\t  if (css)\n\t    { styleManager.add(css, name); }\n\t\n\t  var exists = !!__TAG_IMPL[name];\n\t  __TAG_IMPL[name] = { name: name, tmpl: tmpl, attrs: attrs, fn: fn };\n\t\n\t  if (exists && util.hotReloader)\n\t    { util.hotReloader(name); }\n\t\n\t  return name\n\t}\n\t\n\t/**\n\t * Mount a tag using a specific tag implementation\n\t * @param   { * } selector - tag DOM selector or DOM node/s\n\t * @param   { String } tagName - tag implementation name\n\t * @param   { Object } opts - tag logic\n\t * @returns { Array } new tags instances\n\t */\n\tfunction mount$$1(selector, tagName, opts) {\n\t  var tags = [];\n\t\n\t  function pushTagsTo(root) {\n\t    if (root.tagName) {\n\t      var riotTag = getAttr(root, RIOT_TAG_IS);\n\t\n\t      // have tagName? force riot-tag to be the same\n\t      if (tagName && riotTag !== tagName) {\n\t        riotTag = tagName;\n\t        setAttr(root, RIOT_TAG_IS, tagName);\n\t      }\n\t\n\t      var tag$$1 = mountTo(root, riotTag || root.tagName.toLowerCase(), opts);\n\t\n\t      if (tag$$1)\n\t        { tags.push(tag$$1); }\n\t    } else if (root.length)\n\t      { each(root, pushTagsTo); } // assume nodeList\n\t  }\n\t\n\t  // inject styles into DOM\n\t  styleManager.inject();\n\t\n\t  if (isObject(tagName)) {\n\t    opts = tagName;\n\t    tagName = 0;\n\t  }\n\t\n\t  var elem;\n\t  var allTags;\n\t\n\t  // crawl the DOM to find the tag\n\t  if (isString(selector)) {\n\t    selector = selector === '*' ?\n\t      // select all registered tags\n\t      // & tags found with the riot-tag attribute set\n\t      allTags = selectTags() :\n\t      // or just the ones named like the selector\n\t      selector + selectTags(selector.split(/, */));\n\t\n\t    // make sure to pass always a selector\n\t    // to the querySelectorAll function\n\t    elem = selector ? $$(selector) : [];\n\t  }\n\t  else\n\t    // probably you have passed already a tag or a NodeList\n\t    { elem = selector; }\n\t\n\t  // select all the registered and mount them inside their root elements\n\t  if (tagName === '*') {\n\t    // get all custom tags\n\t    tagName = allTags || selectTags();\n\t    // if the root els it's just a single tag\n\t    if (elem.tagName)\n\t      { elem = $$(tagName, elem); }\n\t    else {\n\t      // select all the children for all the different root elements\n\t      var nodeList = [];\n\t\n\t      each(elem, function (_el) { return nodeList.push($$(tagName, _el)); });\n\t\n\t      elem = nodeList;\n\t    }\n\t    // get rid of the tagName\n\t    tagName = 0;\n\t  }\n\t\n\t  pushTagsTo(elem);\n\t\n\t  return tags\n\t}\n\t\n\t// Create a mixin that could be globally shared across all the tags\n\tvar mixins = {};\n\tvar globals = mixins[GLOBAL_MIXIN] = {};\n\tvar _id = 0;\n\t\n\t/**\n\t * Create/Return a mixin by its name\n\t * @param   { String }  name - mixin name (global mixin if object)\n\t * @param   { Object }  mix - mixin logic\n\t * @param   { Boolean } g - is global?\n\t * @returns { Object }  the mixin logic\n\t */\n\tfunction mixin$$1(name, mix, g) {\n\t  // Unnamed global\n\t  if (isObject(name)) {\n\t    mixin$$1((\"__unnamed_\" + (_id++)), name, true);\n\t    return\n\t  }\n\t\n\t  var store = g ? globals : mixins;\n\t\n\t  // Getter\n\t  if (!mix) {\n\t    if (isUndefined(store[name]))\n\t      { throw new Error('Unregistered mixin: ' + name) }\n\t\n\t    return store[name]\n\t  }\n\t\n\t  // Setter\n\t  store[name] = isFunction(mix) ?\n\t    extend(mix.prototype, store[name] || {}) && mix :\n\t    extend(store[name] || {}, mix);\n\t}\n\t\n\t/**\n\t * Update all the tags instances created\n\t * @returns { Array } all the tags instances\n\t */\n\tfunction update$2() {\n\t  return each(__TAGS_CACHE, function (tag$$1) { return tag$$1.update(); })\n\t}\n\t\n\tfunction unregister$$1(name) {\n\t  delete __TAG_IMPL[name];\n\t}\n\t\n\t// counter to give a unique id to all the Tag instances\n\tvar __uid = 0;\n\t\n\t/**\n\t * We need to update opts for this tag. That requires updating the expressions\n\t * in any attributes on the tag, and then copying the result onto opts.\n\t * @this Tag\n\t * @param   {Boolean} isLoop - is it a loop tag?\n\t * @param   { Tag }  parent - parent tag node\n\t * @param   { Boolean }  isAnonymous - is it a tag without any impl? (a tag not registered)\n\t * @param   { Object }  opts - tag options\n\t * @param   { Array }  instAttrs - tag attributes array\n\t */\n\tfunction updateOpts(isLoop, parent, isAnonymous, opts, instAttrs) {\n\t  // isAnonymous `each` tags treat `dom` and `root` differently. In this case\n\t  // (and only this case) we don't need to do updateOpts, because the regular parse\n\t  // will update those attrs. Plus, isAnonymous tags don't need opts anyway\n\t  if (isLoop && isAnonymous) { return }\n\t\n\t  var ctx = !isAnonymous && isLoop ? this : parent || this;\n\t  each(instAttrs, function (attr) {\n\t    if (attr.expr) { update$1$1.call(ctx, [attr.expr]); }\n\t    opts[toCamel(attr.name)] = attr.expr ? attr.expr.value : attr.value;\n\t  });\n\t}\n\t\n\t\n\t/**\n\t * Tag class\n\t * @constructor\n\t * @param { Object } impl - it contains the tag template, and logic\n\t * @param { Object } conf - tag options\n\t * @param { String } innerHTML - html that eventually we need to inject in the tag\n\t */\n\tfunction Tag$$1(impl, conf, innerHTML) {\n\t\n\t  var opts = extend({}, conf.opts),\n\t    parent = conf.parent,\n\t    isLoop = conf.isLoop,\n\t    isAnonymous = conf.isAnonymous,\n\t    item = cleanUpData(conf.item),\n\t    instAttrs = [], // All attributes on the Tag when it's first parsed\n\t    implAttrs = [], // expressions on this type of Tag\n\t    expressions = [],\n\t    root = conf.root,\n\t    tagName = conf.tagName || getTagName(root),\n\t    isVirtual = tagName === 'virtual',\n\t    propsInSyncWithParent = [],\n\t    dom;\n\t\n\t  // make this tag observable\n\t  observable(this);\n\t  // only call unmount if we have a valid __TAG_IMPL (has name property)\n\t  if (impl.name && root._tag) { root._tag.unmount(true); }\n\t\n\t  // not yet mounted\n\t  this.isMounted = false;\n\t  root.isLoop = isLoop;\n\t\n\t  defineProperty(this, '_internal', {\n\t    isAnonymous: isAnonymous,\n\t    instAttrs: instAttrs,\n\t    innerHTML: innerHTML,\n\t    // these vars will be needed only for the virtual tags\n\t    virts: [],\n\t    tail: null,\n\t    head: null\n\t  });\n\t\n\t  // create a unique id to this tag\n\t  // it could be handy to use it also to improve the virtual dom rendering speed\n\t  defineProperty(this, '_riot_id', ++__uid); // base 1 allows test !t._riot_id\n\t\n\t  extend(this, { parent: parent, root: root, opts: opts }, item);\n\t  // protect the \"tags\" and \"refs\" property from being overridden\n\t  defineProperty(this, 'tags', {});\n\t  defineProperty(this, 'refs', {});\n\t\n\t  dom = mkdom(impl.tmpl, innerHTML, isLoop);\n\t\n\t  /**\n\t   * Update the tag expressions and options\n\t   * @param   { * }  data - data we want to use to extend the tag properties\n\t   * @returns { Tag } the current tag instance\n\t   */\n\t  defineProperty(this, 'update', function tagUpdate(data) {\n\t    if (isFunction(this.shouldUpdate) && !this.shouldUpdate(data)) { return this }\n\t\n\t    // make sure the data passed will not override\n\t    // the component core methods\n\t    data = cleanUpData(data);\n\t\n\t    // inherit properties from the parent, but only for isAnonymous tags\n\t    if (isLoop && isAnonymous) { inheritFrom.apply(this, [this.parent, propsInSyncWithParent]); }\n\t    extend(this, data);\n\t    updateOpts.apply(this, [isLoop, parent, isAnonymous, opts, instAttrs]);\n\t    if (this.isMounted) { this.trigger('update', data); }\n\t    update$1$1.call(this, expressions);\n\t    if (this.isMounted) { this.trigger('updated'); }\n\t\n\t    return this\n\t\n\t  }.bind(this));\n\t\n\t  /**\n\t   * Add a mixin to this tag\n\t   * @returns { Tag } the current tag instance\n\t   */\n\t  defineProperty(this, 'mixin', function tagMixin() {\n\t    var this$1 = this;\n\t\n\t    each(arguments, function (mix) {\n\t      var instance,\n\t        props = [],\n\t        obj;\n\t\n\t      mix = isString(mix) ? mixin$$1(mix) : mix;\n\t\n\t      // check if the mixin is a function\n\t      if (isFunction(mix)) {\n\t        // create the new mixin instance\n\t        instance = new mix();\n\t      } else { instance = mix; }\n\t\n\t      var proto = Object.getPrototypeOf(instance);\n\t\n\t      // build multilevel prototype inheritance chain property list\n\t      do { props = props.concat(Object.getOwnPropertyNames(obj || instance)); }\n\t      while (obj = Object.getPrototypeOf(obj || instance))\n\t\n\t      // loop the keys in the function prototype or the all object keys\n\t      each(props, function (key) {\n\t        // bind methods to this\n\t        // allow mixins to override other properties/parent mixins\n\t        if (key !== 'init') {\n\t          // check for getters/setters\n\t          var descriptor = Object.getOwnPropertyDescriptor(instance, key) || Object.getOwnPropertyDescriptor(proto, key);\n\t          var hasGetterSetter = descriptor && (descriptor.get || descriptor.set);\n\t\n\t          // apply method only if it does not already exist on the instance\n\t          if (!this$1.hasOwnProperty(key) && hasGetterSetter) {\n\t            Object.defineProperty(this$1, key, descriptor);\n\t          } else {\n\t            this$1[key] = isFunction(instance[key]) ?\n\t              instance[key].bind(this$1) :\n\t              instance[key];\n\t          }\n\t        }\n\t      });\n\t\n\t      // init method will be called automatically\n\t      if (instance.init)\n\t        { instance.init.bind(this$1)(); }\n\t    });\n\t    return this\n\t  }.bind(this));\n\t\n\t  /**\n\t   * Mount the current tag instance\n\t   * @returns { Tag } the current tag instance\n\t   */\n\t  defineProperty(this, 'mount', function tagMount() {\n\t    var this$1 = this;\n\t\n\t    root._tag = this; // keep a reference to the tag just created\n\t\n\t    // Read all the attrs on this instance. This give us the info we need for updateOpts\n\t    parseAttributes.apply(parent, [root, root.attributes, function (attr, expr) {\n\t      if (!isAnonymous && RefExpr.isPrototypeOf(expr)) { expr.tag = this$1; }\n\t      attr.expr = expr;\n\t      instAttrs.push(attr);\n\t    }]);\n\t\n\t    // update the root adding custom attributes coming from the compiler\n\t    implAttrs = [];\n\t    walkAttrs(impl.attrs, function (k, v) { implAttrs.push({name: k, value: v}); });\n\t    parseAttributes.apply(this, [root, implAttrs, function (attr, expr) {\n\t      if (expr) { expressions.push(expr); }\n\t      else { setAttr(root, attr.name, attr.value); }\n\t    }]);\n\t\n\t    // children in loop should inherit from true parent\n\t    if (this._parent && isAnonymous) { inheritFrom.apply(this, [this._parent, propsInSyncWithParent]); }\n\t\n\t    // initialiation\n\t    updateOpts.apply(this, [isLoop, parent, isAnonymous, opts, instAttrs]);\n\t\n\t    // add global mixins\n\t    var globalMixin = mixin$$1(GLOBAL_MIXIN);\n\t\n\t    if (globalMixin) {\n\t      for (var i in globalMixin) {\n\t        if (globalMixin.hasOwnProperty(i)) {\n\t          this$1.mixin(globalMixin[i]);\n\t        }\n\t      }\n\t    }\n\t\n\t    if (impl.fn) { impl.fn.call(this, opts); }\n\t\n\t    this.trigger('before-mount');\n\t\n\t    // parse layout after init. fn may calculate args for nested custom tags\n\t    parseExpressions.apply(this, [dom, expressions, false]);\n\t\n\t    this.update(item);\n\t\n\t    if (isLoop && isAnonymous) {\n\t      // update the root attribute for the looped elements\n\t      this.root = root = dom.firstChild;\n\t    } else {\n\t      while (dom.firstChild) { root.appendChild(dom.firstChild); }\n\t      if (root.stub) { root = parent.root; }\n\t    }\n\t\n\t    defineProperty(this, 'root', root);\n\t    this.isMounted = true;\n\t\n\t    // if it's not a child tag we can trigger its mount event\n\t    if (!this.parent || this.parent.isMounted) {\n\t      this.trigger('mount');\n\t    }\n\t    // otherwise we need to wait that the parent event gets triggered\n\t    else { this.parent.one('mount', function () {\n\t      this$1.trigger('mount');\n\t    }); }\n\t\n\t    return this\n\t\n\t  }.bind(this));\n\t\n\t  /**\n\t   * Unmount the tag instance\n\t   * @param { Boolean } mustKeepRoot - if it's true the root node will not be removed\n\t   * @returns { Tag } the current tag instance\n\t   */\n\t  defineProperty(this, 'unmount', function tagUnmount(mustKeepRoot) {\n\t    var this$1 = this;\n\t\n\t    var el = this.root,\n\t      p = el.parentNode,\n\t      ptag,\n\t      tagIndex = __TAGS_CACHE.indexOf(this);\n\t\n\t    this.trigger('before-unmount');\n\t\n\t    // remove this tag instance from the global virtualDom variable\n\t    if (~tagIndex)\n\t      { __TAGS_CACHE.splice(tagIndex, 1); }\n\t\n\t    if (p) {\n\t      if (parent) {\n\t        ptag = getImmediateCustomParentTag(parent);\n\t\n\t        if (isVirtual) {\n\t          Object.keys(this.tags).forEach(function (tagName) {\n\t            arrayishRemove(ptag.tags, tagName, this$1.tags[tagName]);\n\t          });\n\t        } else {\n\t          arrayishRemove(ptag.tags, tagName, this);\n\t        }\n\t      } else {\n\t        while (el.firstChild) { el.removeChild(el.firstChild); }\n\t      }\n\t\n\t      if (!mustKeepRoot) {\n\t        p.removeChild(el);\n\t      } else {\n\t        // the riot-tag and the data-is attributes aren't needed anymore, remove them\n\t        remAttr(p, RIOT_TAG_IS);\n\t      }\n\t    }\n\t\n\t    if (this._internal.virts) {\n\t      each(this._internal.virts, function (v) {\n\t        if (v.parentNode) { v.parentNode.removeChild(v); }\n\t      });\n\t    }\n\t\n\t    // allow expressions to unmount themselves\n\t    unmountAll(expressions);\n\t    each(instAttrs, function (a) { return a.expr && a.expr.unmount && a.expr.unmount(); });\n\t\n\t    this.trigger('unmount');\n\t    this.off('*');\n\t    this.isMounted = false;\n\t\n\t    delete this.root._tag;\n\t\n\t    return this\n\t\n\t  }.bind(this));\n\t}\n\t\n\t/**\n\t * Detect the tag implementation by a DOM node\n\t * @param   { Object } dom - DOM node we need to parse to get its tag implementation\n\t * @returns { Object } it returns an object containing the implementation of a custom tag (template and boot function)\n\t */\n\tfunction getTag(dom) {\n\t  return dom.tagName && __TAG_IMPL[getAttr(dom, RIOT_TAG_IS) ||\n\t    getAttr(dom, RIOT_TAG_IS) || dom.tagName.toLowerCase()]\n\t}\n\t\n\t/**\n\t * Inherit properties from a target tag instance\n\t * @this Tag\n\t * @param   { Tag } target - tag where we will inherit properties\n\t * @param   { Array } propsInSyncWithParent - array of properties to sync with the target\n\t */\n\tfunction inheritFrom(target, propsInSyncWithParent) {\n\t  var this$1 = this;\n\t\n\t  each(Object.keys(target), function (k) {\n\t    // some properties must be always in sync with the parent tag\n\t    var mustSync = !isReservedName(k) && contains(propsInSyncWithParent, k);\n\t\n\t    if (isUndefined(this$1[k]) || mustSync) {\n\t      // track the property to keep in sync\n\t      // so we can keep it updated\n\t      if (!mustSync) { propsInSyncWithParent.push(k); }\n\t      this$1[k] = target[k];\n\t    }\n\t  });\n\t}\n\t\n\t/**\n\t * Move the position of a custom tag in its parent tag\n\t * @this Tag\n\t * @param   { String } tagName - key where the tag was stored\n\t * @param   { Number } newPos - index where the new tag will be stored\n\t */\n\tfunction moveChildTag(tagName, newPos) {\n\t  var parent = this.parent,\n\t    tags;\n\t  // no parent no move\n\t  if (!parent) { return }\n\t\n\t  tags = parent.tags[tagName];\n\t\n\t  if (isArray(tags))\n\t    { tags.splice(newPos, 0, tags.splice(tags.indexOf(this), 1)[0]); }\n\t  else { arrayishAdd(parent.tags, tagName, this); }\n\t}\n\t\n\t/**\n\t * Create a new child tag including it correctly into its parent\n\t * @param   { Object } child - child tag implementation\n\t * @param   { Object } opts - tag options containing the DOM node where the tag will be mounted\n\t * @param   { String } innerHTML - inner html of the child node\n\t * @param   { Object } parent - instance of the parent tag including the child custom tag\n\t * @returns { Object } instance of the new child tag just created\n\t */\n\tfunction initChildTag(child, opts, innerHTML, parent) {\n\t  var tag = new Tag$$1(child, opts, innerHTML),\n\t    tagName = opts.tagName || getTagName(opts.root, true),\n\t    ptag = getImmediateCustomParentTag(parent);\n\t  // fix for the parent attribute in the looped elements\n\t  tag.parent = ptag;\n\t  // store the real parent tag\n\t  // in some cases this could be different from the custom parent tag\n\t  // for example in nested loops\n\t  tag._parent = parent;\n\t\n\t  // add this tag to the custom parent tag\n\t  arrayishAdd(ptag.tags, tagName, tag);\n\t\n\t  // and also to the real parent tag\n\t  if (ptag !== parent)\n\t    { arrayishAdd(parent.tags, tagName, tag); }\n\t\n\t  // empty the child node once we got its template\n\t  // to avoid that its children get compiled multiple times\n\t  opts.root.innerHTML = '';\n\t\n\t  return tag\n\t}\n\t\n\t/**\n\t * Loop backward all the parents tree to detect the first custom parent tag\n\t * @param   { Object } tag - a Tag instance\n\t * @returns { Object } the instance of the first custom parent tag found\n\t */\n\tfunction getImmediateCustomParentTag(tag) {\n\t  var ptag = tag;\n\t  while (ptag._internal.isAnonymous) {\n\t    if (!ptag.parent) { break }\n\t    ptag = ptag.parent;\n\t  }\n\t  return ptag\n\t}\n\t\n\t/**\n\t * Trigger the unmount method on all the expressions\n\t * @param   { Array } expressions - DOM expressions\n\t */\n\tfunction unmountAll(expressions) {\n\t  each(expressions, function(expr) {\n\t    if (expr instanceof Tag$$1) { expr.unmount(true); }\n\t    else if (expr.unmount) { expr.unmount(); }\n\t  });\n\t}\n\t\n\t/**\n\t * Get the tag name of any DOM node\n\t * @param   { Object } dom - DOM node we want to parse\n\t * @param   { Boolean } skipDataIs - hack to ignore the data-is attribute when attaching to parent\n\t * @returns { String } name to identify this dom node in riot\n\t */\n\tfunction getTagName(dom, skipDataIs) {\n\t  var child = getTag(dom),\n\t    namedTag = !skipDataIs && getAttr(dom, RIOT_TAG_IS);\n\t  return namedTag && !tmpl.hasExpr(namedTag) ?\n\t                namedTag :\n\t              child ? child.name : dom.tagName.toLowerCase()\n\t}\n\t\n\t/**\n\t * With this function we avoid that the internal Tag methods get overridden\n\t * @param   { Object } data - options we want to use to extend the tag instance\n\t * @returns { Object } clean object without containing the riot internal reserved words\n\t */\n\tfunction cleanUpData(data) {\n\t  if (!(data instanceof Tag$$1) && !(data && typeof data.trigger === T_FUNCTION))\n\t    { return data }\n\t\n\t  var o = {};\n\t  for (var key in data) {\n\t    if (!RE_RESERVED_NAMES.test(key)) { o[key] = data[key]; }\n\t  }\n\t  return o\n\t}\n\t\n\t/**\n\t * Set the property of an object for a given key. If something already\n\t * exists there, then it becomes an array containing both the old and new value.\n\t * @param { Object } obj - object on which to set the property\n\t * @param { String } key - property name\n\t * @param { Object } value - the value of the property to be set\n\t * @param { Boolean } ensureArray - ensure that the property remains an array\n\t */\n\tfunction arrayishAdd(obj, key, value, ensureArray) {\n\t  var dest = obj[key];\n\t  var isArr = isArray(dest);\n\t\n\t  if (dest && dest === value) { return }\n\t\n\t  // if the key was never set, set it once\n\t  if (!dest && ensureArray) { obj[key] = [value]; }\n\t  else if (!dest) { obj[key] = value; }\n\t  // if it was an array and not yet set\n\t  else if (!isArr || isArr && !contains(dest, value)) {\n\t    if (isArr) { dest.push(value); }\n\t    else { obj[key] = [dest, value]; }\n\t  }\n\t}\n\t\n\t/**\n\t * Removes an item from an object at a given key. If the key points to an array,\n\t * then the item is just removed from the array.\n\t * @param { Object } obj - object on which to remove the property\n\t * @param { String } key - property name\n\t * @param { Object } value - the value of the property to be removed\n\t * @param { Boolean } ensureArray - ensure that the property remains an array\n\t*/\n\tfunction arrayishRemove(obj, key, value, ensureArray) {\n\t  if (isArray(obj[key])) {\n\t    each(obj[key], function(item, i) {\n\t      if (item === value) { obj[key].splice(i, 1); }\n\t    });\n\t    if (!obj[key].length) { delete obj[key]; }\n\t    else if (obj[key].length === 1 && !ensureArray) { obj[key] = obj[key][0]; }\n\t  } else\n\t    { delete obj[key]; } // otherwise just delete the key\n\t}\n\t\n\t/**\n\t * Check whether a DOM node is in stub mode, useful for the riot 'if' directive\n\t * @param   { Object }  dom - DOM node we want to parse\n\t * @returns { Boolean } -\n\t */\n\tfunction isInStub(dom) {\n\t  while (dom) {\n\t    if (dom.inStub)\n\t      { return true }\n\t    dom = dom.parentNode;\n\t  }\n\t  return false\n\t}\n\t\n\t/**\n\t * Mount a tag creating new Tag instance\n\t * @param   { Object } root - dom node where the tag will be mounted\n\t * @param   { String } tagName - name of the riot tag we want to mount\n\t * @param   { Object } opts - options to pass to the Tag instance\n\t * @param   { Object } ctx - optional context that will be used to extend an existing class ( used in riot.Tag )\n\t * @returns { Tag } a new Tag instance\n\t */\n\tfunction mountTo(root, tagName, opts, ctx) {\n\t  var impl = __TAG_IMPL[tagName],\n\t    implClass = __TAG_IMPL[tagName].class,\n\t    tag = ctx || (implClass ? Object.create(implClass.prototype) : {}),\n\t    // cache the inner HTML to fix #855\n\t    innerHTML = root._innerHTML = root._innerHTML || root.innerHTML;\n\t\n\t  // clear the inner html\n\t  root.innerHTML = '';\n\t\n\t  var conf = { root: root, opts: opts };\n\t  if (opts && opts.parent) { conf.parent = opts.parent; }\n\t\n\t  if (impl && root) { Tag$$1.apply(tag, [impl, conf, innerHTML]); }\n\t\n\t  if (tag && tag.mount) {\n\t    tag.mount(true);\n\t    // add this tag to the virtualDom variable\n\t    if (!contains(__TAGS_CACHE, tag)) { __TAGS_CACHE.push(tag); }\n\t  }\n\t\n\t  return tag\n\t}\n\t\n\t\n\t/**\n\t * Adds the elements for a virtual tag\n\t * @this Tag\n\t * @param { Node } src - the node that will do the inserting or appending\n\t * @param { Tag } target - only if inserting, insert before this tag's first child\n\t */\n\tfunction makeVirtual(src, target) {\n\t  var this$1 = this;\n\t\n\t  var head = createDOMPlaceholder(),\n\t    tail = createDOMPlaceholder(),\n\t    frag = createFrag(),\n\t    sib, el;\n\t\n\t  this._internal.head = this.root.insertBefore(head, this.root.firstChild);\n\t  this._internal.tail = this.root.appendChild(tail);\n\t\n\t  el = this._internal.head;\n\t\n\t  while (el) {\n\t    sib = el.nextSibling;\n\t    frag.appendChild(el);\n\t    this$1._internal.virts.push(el); // hold for unmounting\n\t    el = sib;\n\t  }\n\t\n\t  if (target)\n\t    { src.insertBefore(frag, target._internal.head); }\n\t  else\n\t    { src.appendChild(frag); }\n\t}\n\t\n\t/**\n\t * Move virtual tag and all child nodes\n\t * @this Tag\n\t * @param { Node } src  - the node that will do the inserting\n\t * @param { Tag } target - insert before this tag's first child\n\t */\n\tfunction moveVirtual(src, target) {\n\t  var this$1 = this;\n\t\n\t  var el = this._internal.head,\n\t    frag = createFrag(),\n\t    sib;\n\t\n\t  while (el) {\n\t    sib = el.nextSibling;\n\t    frag.appendChild(el);\n\t    el = sib;\n\t    if (el === this$1._internal.tail) {\n\t      frag.appendChild(el);\n\t      src.insertBefore(frag, target._internal.head);\n\t      break\n\t    }\n\t  }\n\t}\n\t\n\t/**\n\t * Get selectors for tags\n\t * @param   { Array } tags - tag names to select\n\t * @returns { String } selector\n\t */\n\tfunction selectTags(tags) {\n\t  // select all tags\n\t  if (!tags) {\n\t    var keys = Object.keys(__TAG_IMPL);\n\t    return keys + selectTags(keys)\n\t  }\n\t\n\t  return tags\n\t    .filter(function (t) { return !/[^-\\w]/.test(t); })\n\t    .reduce(function (list, t) {\n\t      var name = t.trim().toLowerCase();\n\t      return list + \",[\" + RIOT_TAG_IS + \"=\\\"\" + name + \"\\\"]\"\n\t    }, '')\n\t}\n\t\n\t\n\tvar tags = Object.freeze({\n\t\tgetTag: getTag,\n\t\tinheritFrom: inheritFrom,\n\t\tmoveChildTag: moveChildTag,\n\t\tinitChildTag: initChildTag,\n\t\tgetImmediateCustomParentTag: getImmediateCustomParentTag,\n\t\tunmountAll: unmountAll,\n\t\tgetTagName: getTagName,\n\t\tcleanUpData: cleanUpData,\n\t\tarrayishAdd: arrayishAdd,\n\t\tarrayishRemove: arrayishRemove,\n\t\tisInStub: isInStub,\n\t\tmountTo: mountTo,\n\t\tmakeVirtual: makeVirtual,\n\t\tmoveVirtual: moveVirtual,\n\t\tselectTags: selectTags\n\t});\n\t\n\t/**\n\t * Riot public api\n\t */\n\t\n\tvar settings = Object.create(brackets.settings);\n\tvar util = {\n\t  tmpl: tmpl,\n\t  brackets: brackets,\n\t  styleManager: styleManager,\n\t  vdom: __TAGS_CACHE,\n\t  styleNode: styleManager.styleNode,\n\t  // export the riot internal utils as well\n\t  dom: dom,\n\t  check: check,\n\t  misc: misc,\n\t  tags: tags\n\t};\n\t\n\texports.settings = settings;\n\texports.util = util;\n\texports.observable = observable;\n\texports.Tag = Tag$1;\n\texports.tag = tag$$1;\n\texports.tag2 = tag2$$1;\n\texports.mount = mount$$1;\n\texports.mixin = mixin$$1;\n\texports.update = update$2;\n\texports.unregister = unregister$$1;\n\t\n\tObject.defineProperty(exports, '__esModule', { value: true });\n\t\n\t})));\n\t\n\t/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(/*! riot */ 2)))\n\n/***/ },\n/* 3 */\n/*!*************************************!*\\\n  !*** ./~/style-loader/addStyles.js ***!\n  \\*************************************/\n/***/ function(module, exports, __webpack_require__) {\n\n\t/*\r\n\t\tMIT License http://www.opensource.org/licenses/mit-license.php\r\n\t\tAuthor Tobias Koppers @sokra\r\n\t*/\r\n\tvar stylesInDom = {},\r\n\t\tmemoize = function(fn) {\r\n\t\t\tvar memo;\r\n\t\t\treturn function () {\r\n\t\t\t\tif (typeof memo === \"undefined\") memo = fn.apply(this, arguments);\r\n\t\t\t\treturn memo;\r\n\t\t\t};\r\n\t\t},\r\n\t\tisOldIE = memoize(function() {\r\n\t\t\treturn /msie [6-9]\\b/.test(window.navigator.userAgent.toLowerCase());\r\n\t\t}),\r\n\t\tgetHeadElement = memoize(function () {\r\n\t\t\treturn document.head || document.getElementsByTagName(\"head\")[0];\r\n\t\t}),\r\n\t\tsingletonElement = null,\r\n\t\tsingletonCounter = 0,\r\n\t\tstyleElementsInsertedAtTop = [];\r\n\t\r\n\tmodule.exports = function(list, options) {\r\n\t\tif(true) {\r\n\t\t\tif(typeof document !== \"object\") throw new Error(\"The style-loader cannot be used in a non-browser environment\");\r\n\t\t}\r\n\t\r\n\t\toptions = options || {};\r\n\t\t// Force single-tag solution on IE6-9, which has a hard limit on the # of <style>\r\n\t\t// tags it will allow on a page\r\n\t\tif (typeof options.singleton === \"undefined\") options.singleton = isOldIE();\r\n\t\r\n\t\t// By default, add <style> tags to the bottom of <head>.\r\n\t\tif (typeof options.insertAt === \"undefined\") options.insertAt = \"bottom\";\r\n\t\r\n\t\tvar styles = listToStyles(list);\r\n\t\taddStylesToDom(styles, options);\r\n\t\r\n\t\treturn function update(newList) {\r\n\t\t\tvar mayRemove = [];\r\n\t\t\tfor(var i = 0; i < styles.length; i++) {\r\n\t\t\t\tvar item = styles[i];\r\n\t\t\t\tvar domStyle = stylesInDom[item.id];\r\n\t\t\t\tdomStyle.refs--;\r\n\t\t\t\tmayRemove.push(domStyle);\r\n\t\t\t}\r\n\t\t\tif(newList) {\r\n\t\t\t\tvar newStyles = listToStyles(newList);\r\n\t\t\t\taddStylesToDom(newStyles, options);\r\n\t\t\t}\r\n\t\t\tfor(var i = 0; i < mayRemove.length; i++) {\r\n\t\t\t\tvar domStyle = mayRemove[i];\r\n\t\t\t\tif(domStyle.refs === 0) {\r\n\t\t\t\t\tfor(var j = 0; j < domStyle.parts.length; j++)\r\n\t\t\t\t\t\tdomStyle.parts[j]();\r\n\t\t\t\t\tdelete stylesInDom[domStyle.id];\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t};\r\n\t}\r\n\t\r\n\tfunction addStylesToDom(styles, options) {\r\n\t\tfor(var i = 0; i < styles.length; i++) {\r\n\t\t\tvar item = styles[i];\r\n\t\t\tvar domStyle = stylesInDom[item.id];\r\n\t\t\tif(domStyle) {\r\n\t\t\t\tdomStyle.refs++;\r\n\t\t\t\tfor(var j = 0; j < domStyle.parts.length; j++) {\r\n\t\t\t\t\tdomStyle.parts[j](item.parts[j]);\r\n\t\t\t\t}\r\n\t\t\t\tfor(; j < item.parts.length; j++) {\r\n\t\t\t\t\tdomStyle.parts.push(addStyle(item.parts[j], options));\r\n\t\t\t\t}\r\n\t\t\t} else {\r\n\t\t\t\tvar parts = [];\r\n\t\t\t\tfor(var j = 0; j < item.parts.length; j++) {\r\n\t\t\t\t\tparts.push(addStyle(item.parts[j], options));\r\n\t\t\t\t}\r\n\t\t\t\tstylesInDom[item.id] = {id: item.id, refs: 1, parts: parts};\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n\t\r\n\tfunction listToStyles(list) {\r\n\t\tvar styles = [];\r\n\t\tvar newStyles = {};\r\n\t\tfor(var i = 0; i < list.length; i++) {\r\n\t\t\tvar item = list[i];\r\n\t\t\tvar id = item[0];\r\n\t\t\tvar css = item[1];\r\n\t\t\tvar media = item[2];\r\n\t\t\tvar sourceMap = item[3];\r\n\t\t\tvar part = {css: css, media: media, sourceMap: sourceMap};\r\n\t\t\tif(!newStyles[id])\r\n\t\t\t\tstyles.push(newStyles[id] = {id: id, parts: [part]});\r\n\t\t\telse\r\n\t\t\t\tnewStyles[id].parts.push(part);\r\n\t\t}\r\n\t\treturn styles;\r\n\t}\r\n\t\r\n\tfunction insertStyleElement(options, styleElement) {\r\n\t\tvar head = getHeadElement();\r\n\t\tvar lastStyleElementInsertedAtTop = styleElementsInsertedAtTop[styleElementsInsertedAtTop.length - 1];\r\n\t\tif (options.insertAt === \"top\") {\r\n\t\t\tif(!lastStyleElementInsertedAtTop) {\r\n\t\t\t\thead.insertBefore(styleElement, head.firstChild);\r\n\t\t\t} else if(lastStyleElementInsertedAtTop.nextSibling) {\r\n\t\t\t\thead.insertBefore(styleElement, lastStyleElementInsertedAtTop.nextSibling);\r\n\t\t\t} else {\r\n\t\t\t\thead.appendChild(styleElement);\r\n\t\t\t}\r\n\t\t\tstyleElementsInsertedAtTop.push(styleElement);\r\n\t\t} else if (options.insertAt === \"bottom\") {\r\n\t\t\thead.appendChild(styleElement);\r\n\t\t} else {\r\n\t\t\tthrow new Error(\"Invalid value for parameter 'insertAt'. Must be 'top' or 'bottom'.\");\r\n\t\t}\r\n\t}\r\n\t\r\n\tfunction removeStyleElement(styleElement) {\r\n\t\tstyleElement.parentNode.removeChild(styleElement);\r\n\t\tvar idx = styleElementsInsertedAtTop.indexOf(styleElement);\r\n\t\tif(idx >= 0) {\r\n\t\t\tstyleElementsInsertedAtTop.splice(idx, 1);\r\n\t\t}\r\n\t}\r\n\t\r\n\tfunction createStyleElement(options) {\r\n\t\tvar styleElement = document.createElement(\"style\");\r\n\t\tstyleElement.type = \"text/css\";\r\n\t\tinsertStyleElement(options, styleElement);\r\n\t\treturn styleElement;\r\n\t}\r\n\t\r\n\tfunction createLinkElement(options) {\r\n\t\tvar linkElement = document.createElement(\"link\");\r\n\t\tlinkElement.rel = \"stylesheet\";\r\n\t\tinsertStyleElement(options, linkElement);\r\n\t\treturn linkElement;\r\n\t}\r\n\t\r\n\tfunction addStyle(obj, options) {\r\n\t\tvar styleElement, update, remove;\r\n\t\r\n\t\tif (options.singleton) {\r\n\t\t\tvar styleIndex = singletonCounter++;\r\n\t\t\tstyleElement = singletonElement || (singletonElement = createStyleElement(options));\r\n\t\t\tupdate = applyToSingletonTag.bind(null, styleElement, styleIndex, false);\r\n\t\t\tremove = applyToSingletonTag.bind(null, styleElement, styleIndex, true);\r\n\t\t} else if(obj.sourceMap &&\r\n\t\t\ttypeof URL === \"function\" &&\r\n\t\t\ttypeof URL.createObjectURL === \"function\" &&\r\n\t\t\ttypeof URL.revokeObjectURL === \"function\" &&\r\n\t\t\ttypeof Blob === \"function\" &&\r\n\t\t\ttypeof btoa === \"function\") {\r\n\t\t\tstyleElement = createLinkElement(options);\r\n\t\t\tupdate = updateLink.bind(null, styleElement);\r\n\t\t\tremove = function() {\r\n\t\t\t\tremoveStyleElement(styleElement);\r\n\t\t\t\tif(styleElement.href)\r\n\t\t\t\t\tURL.revokeObjectURL(styleElement.href);\r\n\t\t\t};\r\n\t\t} else {\r\n\t\t\tstyleElement = createStyleElement(options);\r\n\t\t\tupdate = applyToTag.bind(null, styleElement);\r\n\t\t\tremove = function() {\r\n\t\t\t\tremoveStyleElement(styleElement);\r\n\t\t\t};\r\n\t\t}\r\n\t\r\n\t\tupdate(obj);\r\n\t\r\n\t\treturn function updateStyle(newObj) {\r\n\t\t\tif(newObj) {\r\n\t\t\t\tif(newObj.css === obj.css && newObj.media === obj.media && newObj.sourceMap === obj.sourceMap)\r\n\t\t\t\t\treturn;\r\n\t\t\t\tupdate(obj = newObj);\r\n\t\t\t} else {\r\n\t\t\t\tremove();\r\n\t\t\t}\r\n\t\t};\r\n\t}\r\n\t\r\n\tvar replaceText = (function () {\r\n\t\tvar textStore = [];\r\n\t\r\n\t\treturn function (index, replacement) {\r\n\t\t\ttextStore[index] = replacement;\r\n\t\t\treturn textStore.filter(Boolean).join('\\n');\r\n\t\t};\r\n\t})();\r\n\t\r\n\tfunction applyToSingletonTag(styleElement, index, remove, obj) {\r\n\t\tvar css = remove ? \"\" : obj.css;\r\n\t\r\n\t\tif (styleElement.styleSheet) {\r\n\t\t\tstyleElement.styleSheet.cssText = replaceText(index, css);\r\n\t\t} else {\r\n\t\t\tvar cssNode = document.createTextNode(css);\r\n\t\t\tvar childNodes = styleElement.childNodes;\r\n\t\t\tif (childNodes[index]) styleElement.removeChild(childNodes[index]);\r\n\t\t\tif (childNodes.length) {\r\n\t\t\t\tstyleElement.insertBefore(cssNode, childNodes[index]);\r\n\t\t\t} else {\r\n\t\t\t\tstyleElement.appendChild(cssNode);\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n\t\r\n\tfunction applyToTag(styleElement, obj) {\r\n\t\tvar css = obj.css;\r\n\t\tvar media = obj.media;\r\n\t\r\n\t\tif(media) {\r\n\t\t\tstyleElement.setAttribute(\"media\", media)\r\n\t\t}\r\n\t\r\n\t\tif(styleElement.styleSheet) {\r\n\t\t\tstyleElement.styleSheet.cssText = css;\r\n\t\t} else {\r\n\t\t\twhile(styleElement.firstChild) {\r\n\t\t\t\tstyleElement.removeChild(styleElement.firstChild);\r\n\t\t\t}\r\n\t\t\tstyleElement.appendChild(document.createTextNode(css));\r\n\t\t}\r\n\t}\r\n\t\r\n\tfunction updateLink(linkElement, obj) {\r\n\t\tvar css = obj.css;\r\n\t\tvar sourceMap = obj.sourceMap;\r\n\t\r\n\t\tif(sourceMap) {\r\n\t\t\t// http://stackoverflow.com/a/26603875\r\n\t\t\tcss += \"\\n/*# sourceMappingURL=data:application/json;base64,\" + btoa(unescape(encodeURIComponent(JSON.stringify(sourceMap)))) + \" */\";\r\n\t\t}\r\n\t\r\n\t\tvar blob = new Blob([css], { type: \"text/css\" });\r\n\t\r\n\t\tvar oldSrc = linkElement.href;\r\n\t\r\n\t\tlinkElement.href = URL.createObjectURL(blob);\r\n\t\r\n\t\tif(oldSrc)\r\n\t\t\tURL.revokeObjectURL(oldSrc);\r\n\t}\r\n\n\n/***/ },\n/* 4 */\n/*!*************************!*\\\n  !*** ./client/index.js ***!\n  \\*************************/\n/***/ function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\t\n\tconst riot = __webpack_require__(/*! riot */ 2);\n\t\n\t__webpack_require__(/*! ./app.tag */ 5);\n\triot.mount('app');\n\t\n\t// Router\n\t//require('./router.js')\n\t// SASS\n\t__webpack_require__(/*! ./stylesheets/normalize.scss */ 11);\n\t__webpack_require__(/*! ./stylesheets/flex-grid.scss */ 10);\n\t__webpack_require__(/*! ./stylesheets/default-hljs.scss */ 9);\n\n/***/ },\n/* 5 */\n/*!************************!*\\\n  !*** ./client/app.tag ***!\n  \\************************/\n/***/ function(module, exports, __webpack_require__) {\n\n\t/* WEBPACK VAR INJECTION */(function(riot) {\n\triot.tag2('require', '', '', 'components layouts basic-layout tag', function (opts) {});\n\t\n\triot.tag2('app', '<basic-layout></basic-layout> <h1>hogehoge</h1>', '', '', function (opts) {});\n\t/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(/*! riot */ 2)))\n\n/***/ },\n/* 6 */\n/*!*****************************************************************************!*\\\n  !*** ./~/css-loader!./~/sass-loader!./client/stylesheets/default-hljs.scss ***!\n  \\*****************************************************************************/\n/***/ function(module, exports, __webpack_require__) {\n\n\texports = module.exports = __webpack_require__(/*! ./../../~/css-loader/lib/css-base.js */ 1)();\n\t// imports\n\t\n\t\n\t// module\n\texports.push([module.id, \".hljs{display:block;overflow-x:auto;padding:.5em;background:#f0f0f0;-webkit-text-size-adjust:none}.hljs,.hljs-subst,.hljs-tag .hljs-title,.nginx .hljs-title{color:#000}.apache .hljs-cbracket,.apache .hljs-tag,.asciidoc .hljs-header,.bash .hljs-variable,.coffeescript .hljs-attribute,.django .hljs-variable,.erlang_repl .hljs-function_or_atom,.haml .hljs-symbol,.hljs-addition,.hljs-constant,.hljs-flow,.hljs-name,.hljs-parent,.hljs-pragma,.hljs-preprocessor,.hljs-rule .hljs-value,.hljs-stream,.hljs-string,.hljs-tag .hljs-value,.hljs-template_tag,.hljs-title,.markdown .hljs-header,.pf .hljs-variable,.ruby .hljs-symbol,.ruby .hljs-symbol .hljs-string,.smalltalk .hljs-class,.tex .hljs-command,.tex .hljs-special,.tp .hljs-variable{color:#800}.asciidoc .hljs-blockquote,.diff .hljs-header,.hljs-annotation,.hljs-chunk,.hljs-comment,.markdown .hljs-blockquote,.smartquote{color:#888}.asciidoc .hljs-bullet,.asciidoc .hljs-link_url,.go .hljs-constant,.hljs-change,.hljs-date,.hljs-hexcolor,.hljs-literal,.hljs-number,.hljs-regexp,.lasso .hljs-variable,.makefile .hljs-variable,.markdown .hljs-bullet,.markdown .hljs-link_url,.smalltalk .hljs-char,.smalltalk .hljs-symbol{color:#080}.apache .hljs-sqbracket,.asciidoc .hljs-attribute,.asciidoc .hljs-link_label,.clojure .hljs-attribute,.coffeescript .hljs-property,.erlang_repl .hljs-reserved,.haml .hljs-bullet,.hljs-array,.hljs-attr_selector,.hljs-decorator,.hljs-deletion,.hljs-doctype,.hljs-envvar,.hljs-filter .hljs-argument,.hljs-important,.hljs-label,.hljs-localvars,.hljs-phony,.hljs-pi,.hljs-prompt,.hljs-pseudo,.hljs-shebang,.lasso .hljs-attribute,.markdown .hljs-link_label,.nginx .hljs-built_in,.ruby .hljs-string,.tex .hljs-formula,.vhdl .hljs-attribute{color:#88f}.apache .hljs-tag,.asciidoc .hljs-strong,.bash .hljs-variable,.css .hljs-tag,.hljs-built_in,.hljs-doctag,.hljs-id,.hljs-keyword,.hljs-request,.hljs-status,.hljs-title,.hljs-type,.hljs-typename,.hljs-winutils,.markdown .hljs-strong,.pf .hljs-variable,.smalltalk .hljs-class,.tex .hljs-command,.tp .hljs-data,.tp .hljs-io{font-weight:700}.asciidoc .hljs-emphasis,.markdown .hljs-emphasis,.tp .hljs-units{font-style:italic}.nginx .hljs-built_in{font-weight:400}.coffeescript .javascript,.javascript .xml,.lasso .markup,.tex .hljs-formula,.xml .css,.xml .hljs-cdata,.xml .javascript,.xml .vbscript{opacity:.5}\", \"\"]);\n\t\n\t// exports\n\n\n/***/ },\n/* 7 */\n/*!**************************************************************************!*\\\n  !*** ./~/css-loader!./~/sass-loader!./client/stylesheets/flex-grid.scss ***!\n  \\**************************************************************************/\n/***/ function(module, exports, __webpack_require__) {\n\n\texports = module.exports = __webpack_require__(/*! ./../../~/css-loader/lib/css-base.js */ 1)();\n\t// imports\n\t\n\t\n\t// module\n\texports.push([module.id, \".row{box-sizing:border-box;display:flex;flex-direction:row;flex-wrap:wrap;margin-left:-.5rem;margin-right:-.5rem}.col-lg,.col-lg-1,.col-lg-2,.col-lg-3,.col-lg-4,.col-lg-5,.col-lg-6,.col-lg-7,.col-lg-8,.col-lg-9,.col-lg-10,.col-lg-11,.col-lg-12,.col-md,.col-md-1,.col-md-2,.col-md-3,.col-md-4,.col-md-5,.col-md-6,.col-md-7,.col-md-8,.col-md-9,.col-md-10,.col-md-11,.col-md-12,.col-sm,.col-sm-1,.col-sm-2,.col-sm-3,.col-sm-4,.col-sm-5,.col-sm-6,.col-sm-7,.col-sm-8,.col-sm-9,.col-sm-10,.col-sm-11,.col-sm-12,.col-xs,.col-xs-1,.col-xs-2,.col-xs-3,.col-xs-4,.col-xs-5,.col-xs-6,.col-xs-7,.col-xs-8,.col-xs-9,.col-xs-10,.col-xs-11,.col-xs-12{box-sizing:border-box;display:flex;flex-direction:column;flex-grow:0;flex-shrink:0;padding-left:.5rem;padding-right:.5rem}.col-lg,.col-md,.col-sm,.col-xs{flex-grow:1;flex-basis:0;max-width:100%}.col-xs-1{flex-basis:8.33333%;max-width:8.33333%}.col-xs-2{flex-basis:16.66667%;max-width:16.66667%}.col-xs-3{flex-basis:25%;max-width:25%}.col-xs-4{flex-basis:33.33333%;max-width:33.33333%}.col-xs-5{flex-basis:41.66667%;max-width:41.66667%}.col-xs-6{flex-basis:50%;max-width:50%}.col-xs-7{flex-basis:58.33333%;max-width:58.33333%}.col-xs-8{flex-basis:66.66667%;max-width:66.66667%}.col-xs-9{flex-basis:75%;max-width:75%}.col-xs-10{flex-basis:83.33333%;max-width:83.33333%}.col-xs-11{flex-basis:91.66667%;max-width:91.66667%}.col-xs-12{flex-basis:100%;max-width:100%}.off-xs-1{margin-left:8.33333%}.off-xs-2{margin-left:16.66667%}.off-xs-3{margin-left:25%}.off-xs-4{margin-left:33.33333%}.off-xs-5{margin-left:41.66667%}.off-xs-6{margin-left:50%}.off-xs-7{margin-left:58.33333%}.off-xs-8{margin-left:66.66667%}.off-xs-9{margin-left:75%}.off-xs-10{margin-left:83.33333%}.off-xs-11{margin-left:91.66667%}@media only screen and (min-width:768px){.col-sm-1{flex-basis:8.33333%;max-width:8.33333%}.col-sm-2{flex-basis:16.66667%;max-width:16.66667%}.col-sm-3{flex-basis:25%;max-width:25%}.col-sm-4{flex-basis:33.33333%;max-width:33.33333%}.col-sm-5{flex-basis:41.66667%;max-width:41.66667%}.col-sm-6{flex-basis:50%;max-width:50%}.col-sm-7{flex-basis:58.33333%;max-width:58.33333%}.col-sm-8{flex-basis:66.66667%;max-width:66.66667%}.col-sm-9{flex-basis:75%;max-width:75%}.col-sm-10{flex-basis:83.33333%;max-width:83.33333%}.col-sm-11{flex-basis:91.66667%;max-width:91.66667%}.col-sm-12{flex-basis:100%;max-width:100%}.off-sm-1{margin-left:8.33333%}.off-sm-2{margin-left:16.66667%}.off-sm-3{margin-left:25%}.off-sm-4{margin-left:33.33333%}.off-sm-5{margin-left:41.66667%}.off-sm-6{margin-left:50%}.off-sm-7{margin-left:58.33333%}.off-sm-8{margin-left:66.66667%}.off-sm-9{margin-left:75%}.off-sm-10{margin-left:83.33333%}.off-sm-11{margin-left:91.66667%}}@media only screen and (min-width:992px){.col-md-1{flex-basis:8.33333%;max-width:8.33333%}.col-md-2{flex-basis:16.66667%;max-width:16.66667%}.col-md-3{flex-basis:25%;max-width:25%}.col-md-4{flex-basis:33.33333%;max-width:33.33333%}.col-md-5{flex-basis:41.66667%;max-width:41.66667%}.col-md-6{flex-basis:50%;max-width:50%}.col-md-7{flex-basis:58.33333%;max-width:58.33333%}.col-md-8{flex-basis:66.66667%;max-width:66.66667%}.col-md-9{flex-basis:75%;max-width:75%}.col-md-10{flex-basis:83.33333%;max-width:83.33333%}.col-md-11{flex-basis:91.66667%;max-width:91.66667%}.col-md-12{flex-basis:100%;max-width:100%}.off-md-1{margin-left:8.33333%}.off-md-2{margin-left:16.66667%}.off-md-3{margin-left:25%}.off-md-4{margin-left:33.33333%}.off-md-5{margin-left:41.66667%}.off-md-6{margin-left:50%}.off-md-7{margin-left:58.33333%}.off-md-8{margin-left:66.66667%}.off-md-9{margin-left:75%}.off-md-10{margin-left:83.33333%}.off-md-11{margin-left:91.66667%}}@media only screen and (min-width:1200px){.col-lg-1{flex-basis:8.33333%;max-width:8.33333%}.col-lg-2{flex-basis:16.66667%;max-width:16.66667%}.col-lg-3{flex-basis:25%;max-width:25%}.col-lg-4{flex-basis:33.33333%;max-width:33.33333%}.col-lg-5{flex-basis:41.66667%;max-width:41.66667%}.col-lg-6{flex-basis:50%;max-width:50%}.col-lg-7{flex-basis:58.33333%;max-width:58.33333%}.col-lg-8{flex-basis:66.66667%;max-width:66.66667%}.col-lg-9{flex-basis:75%;max-width:75%}.col-lg-10{flex-basis:83.33333%;max-width:83.33333%}.col-lg-11{flex-basis:91.66667%;max-width:91.66667%}.col-lg-12{flex-basis:100%;max-width:100%}.off-lg-1{margin-left:8.33333%}.off-lg-2{margin-left:16.66667%}.off-lg-3{margin-left:25%}.off-lg-4{margin-left:33.33333%}.off-lg-5{margin-left:41.66667%}.off-lg-6{margin-left:50%}.off-lg-7{margin-left:58.33333%}.off-lg-8{margin-left:66.66667%}.off-lg-9{margin-left:75%}.off-lg-10{margin-left:83.33333%}.off-lg-11{margin-left:91.66667%}}\", \"\"]);\n\t\n\t// exports\n\n\n/***/ },\n/* 8 */\n/*!**************************************************************************!*\\\n  !*** ./~/css-loader!./~/sass-loader!./client/stylesheets/normalize.scss ***!\n  \\**************************************************************************/\n/***/ function(module, exports, __webpack_require__) {\n\n\texports = module.exports = __webpack_require__(/*! ./../../~/css-loader/lib/css-base.js */ 1)();\n\t// imports\n\t\n\t\n\t// module\n\texports.push([module.id, \"html{font-family:sans-serif;-ms-text-size-adjust:100%;-webkit-text-size-adjust:100%}body{margin:0}article,aside,details,figcaption,figure,footer,header,hgroup,main,menu,nav,section,summary{display:block}audio,canvas,progress,video{display:inline-block;vertical-align:baseline}audio:not([controls]){display:none;height:0}[hidden],template{display:none}a{background-color:transparent}a:active,a:hover{outline:0}abbr[title]{border-bottom:1px dotted}b,strong{font-weight:700}dfn{font-style:italic}h1{font-size:2em;margin:.67em 0}mark{background:#ff0;color:#000}small{font-size:80%}sub,sup{font-size:75%;line-height:0;position:relative;vertical-align:baseline}sup{top:-.5em}sub{bottom:-.25em}img{border:0}svg:not(:root){overflow:hidden}figure{margin:1em 40px}hr{box-sizing:content-box;height:0}pre{overflow:auto}code,kbd,pre,samp{font-family:monospace,monospace;font-size:1em}button,input,optgroup,select,textarea{color:inherit;font:inherit;margin:0}button{overflow:visible}button,select{text-transform:none}button,html input[type=button],input[type=reset],input[type=submit]{-webkit-appearance:button;cursor:pointer}button[disabled],html input[disabled]{cursor:default}button::-moz-focus-inner,input::-moz-focus-inner{border:0;padding:0}input{line-height:normal}input[type=checkbox],input[type=radio]{box-sizing:border-box;padding:0}input[type=number]::-webkit-inner-spin-button,input[type=number]::-webkit-outer-spin-button{height:auto}input[type=search]{-webkit-appearance:textfield;box-sizing:content-box}input[type=search]::-webkit-search-cancel-button,input[type=search]::-webkit-search-decoration{-webkit-appearance:none}fieldset{border:1px solid silver;margin:0 2px;padding:.35em .625em .75em}legend{border:0;padding:0}textarea{overflow:auto}optgroup{font-weight:700}table{border-collapse:collapse;border-spacing:0}td,th{padding:0}\", \"\"]);\n\t\n\t// exports\n\n\n/***/ },\n/* 9 */\n/*!**********************************************!*\\\n  !*** ./client/stylesheets/default-hljs.scss ***!\n  \\**********************************************/\n/***/ function(module, exports, __webpack_require__) {\n\n\t// style-loader: Adds some css to the DOM by adding a <style> tag\n\t\n\t// load the styles\n\tvar content = __webpack_require__(/*! !./../../~/css-loader!./../../~/sass-loader!./default-hljs.scss */ 6);\n\tif(typeof content === 'string') content = [[module.id, content, '']];\n\t// add the styles to the DOM\n\tvar update = __webpack_require__(/*! ./../../~/style-loader/addStyles.js */ 3)(content, {});\n\tif(content.locals) module.exports = content.locals;\n\t// Hot Module Replacement\n\tif(false) {\n\t\t// When the styles change, update the <style> tags\n\t\tif(!content.locals) {\n\t\t\tmodule.hot.accept(\"!!./../../node_modules/css-loader/index.js!./../../node_modules/sass-loader/index.js!./default-hljs.scss\", function() {\n\t\t\t\tvar newContent = require(\"!!./../../node_modules/css-loader/index.js!./../../node_modules/sass-loader/index.js!./default-hljs.scss\");\n\t\t\t\tif(typeof newContent === 'string') newContent = [[module.id, newContent, '']];\n\t\t\t\tupdate(newContent);\n\t\t\t});\n\t\t}\n\t\t// When the module is disposed, remove the <style> tags\n\t\tmodule.hot.dispose(function() { update(); });\n\t}\n\n/***/ },\n/* 10 */\n/*!*******************************************!*\\\n  !*** ./client/stylesheets/flex-grid.scss ***!\n  \\*******************************************/\n/***/ function(module, exports, __webpack_require__) {\n\n\t// style-loader: Adds some css to the DOM by adding a <style> tag\n\t\n\t// load the styles\n\tvar content = __webpack_require__(/*! !./../../~/css-loader!./../../~/sass-loader!./flex-grid.scss */ 7);\n\tif(typeof content === 'string') content = [[module.id, content, '']];\n\t// add the styles to the DOM\n\tvar update = __webpack_require__(/*! ./../../~/style-loader/addStyles.js */ 3)(content, {});\n\tif(content.locals) module.exports = content.locals;\n\t// Hot Module Replacement\n\tif(false) {\n\t\t// When the styles change, update the <style> tags\n\t\tif(!content.locals) {\n\t\t\tmodule.hot.accept(\"!!./../../node_modules/css-loader/index.js!./../../node_modules/sass-loader/index.js!./flex-grid.scss\", function() {\n\t\t\t\tvar newContent = require(\"!!./../../node_modules/css-loader/index.js!./../../node_modules/sass-loader/index.js!./flex-grid.scss\");\n\t\t\t\tif(typeof newContent === 'string') newContent = [[module.id, newContent, '']];\n\t\t\t\tupdate(newContent);\n\t\t\t});\n\t\t}\n\t\t// When the module is disposed, remove the <style> tags\n\t\tmodule.hot.dispose(function() { update(); });\n\t}\n\n/***/ },\n/* 11 */\n/*!*******************************************!*\\\n  !*** ./client/stylesheets/normalize.scss ***!\n  \\*******************************************/\n/***/ function(module, exports, __webpack_require__) {\n\n\t// style-loader: Adds some css to the DOM by adding a <style> tag\n\t\n\t// load the styles\n\tvar content = __webpack_require__(/*! !./../../~/css-loader!./../../~/sass-loader!./normalize.scss */ 8);\n\tif(typeof content === 'string') content = [[module.id, content, '']];\n\t// add the styles to the DOM\n\tvar update = __webpack_require__(/*! ./../../~/style-loader/addStyles.js */ 3)(content, {});\n\tif(content.locals) module.exports = content.locals;\n\t// Hot Module Replacement\n\tif(false) {\n\t\t// When the styles change, update the <style> tags\n\t\tif(!content.locals) {\n\t\t\tmodule.hot.accept(\"!!./../../node_modules/css-loader/index.js!./../../node_modules/sass-loader/index.js!./normalize.scss\", function() {\n\t\t\t\tvar newContent = require(\"!!./../../node_modules/css-loader/index.js!./../../node_modules/sass-loader/index.js!./normalize.scss\");\n\t\t\t\tif(typeof newContent === 'string') newContent = [[module.id, newContent, '']];\n\t\t\t\tupdate(newContent);\n\t\t\t});\n\t\t}\n\t\t// When the module is disposed, remove the <style> tags\n\t\tmodule.hot.dispose(function() { update(); });\n\t}\n\n/***/ }\n/******/ ]);\n\n\n// WEBPACK FOOTER //\n// bundle.js"," \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId])\n \t\t\treturn installedModules[moduleId].exports;\n\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\texports: {},\n \t\t\tid: moduleId,\n \t\t\tloaded: false\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.loaded = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"/dist/\";\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(0);\n\n\n\n// WEBPACK FOOTER //\n// webpack/bootstrap 423edeb7959157fa994e","/*\r\n\tMIT License http://www.opensource.org/licenses/mit-license.php\r\n\tAuthor Tobias Koppers @sokra\r\n*/\r\n// css base code, injected by the css-loader\r\nmodule.exports = function() {\r\n\tvar list = [];\r\n\r\n\t// return the list of modules as css string\r\n\tlist.toString = function toString() {\r\n\t\tvar result = [];\r\n\t\tfor(var i = 0; i < this.length; i++) {\r\n\t\t\tvar item = this[i];\r\n\t\t\tif(item[2]) {\r\n\t\t\t\tresult.push(\"@media \" + item[2] + \"{\" + item[1] + \"}\");\r\n\t\t\t} else {\r\n\t\t\t\tresult.push(item[1]);\r\n\t\t\t}\r\n\t\t}\r\n\t\treturn result.join(\"\");\r\n\t};\r\n\r\n\t// import a list of modules into the list\r\n\tlist.i = function(modules, mediaQuery) {\r\n\t\tif(typeof modules === \"string\")\r\n\t\t\tmodules = [[null, modules, \"\"]];\r\n\t\tvar alreadyImportedModules = {};\r\n\t\tfor(var i = 0; i < this.length; i++) {\r\n\t\t\tvar id = this[i][0];\r\n\t\t\tif(typeof id === \"number\")\r\n\t\t\t\talreadyImportedModules[id] = true;\r\n\t\t}\r\n\t\tfor(i = 0; i < modules.length; i++) {\r\n\t\t\tvar item = modules[i];\r\n\t\t\t// skip already imported module\r\n\t\t\t// this implementation is not 100% perfect for weird media query combinations\r\n\t\t\t//  when a module is imported multiple times with different media queries.\r\n\t\t\t//  I hope this will never occur (Hey this way we have smaller bundles)\r\n\t\t\tif(typeof item[0] !== \"number\" || !alreadyImportedModules[item[0]]) {\r\n\t\t\t\tif(mediaQuery && !item[2]) {\r\n\t\t\t\t\titem[2] = mediaQuery;\r\n\t\t\t\t} else if(mediaQuery) {\r\n\t\t\t\t\titem[2] = \"(\" + item[2] + \") and (\" + mediaQuery + \")\";\r\n\t\t\t\t}\r\n\t\t\t\tlist.push(item);\r\n\t\t\t}\r\n\t\t}\r\n\t};\r\n\treturn list;\r\n};\r\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/css-loader/lib/css-base.js\n// module id = 1\n// module chunks = 0","/* Riot v3.0.1, @license MIT */\n(function (global, factory) {\n  typeof exports === 'object' && typeof module !== 'undefined' ? factory(exports) :\n  typeof define === 'function' && define.amd ? define(['exports'], factory) :\n  (factory((global.riot = global.riot || {})));\n}(this, (function (exports) { 'use strict';\n\nvar __TAGS_CACHE = [];\nvar __TAG_IMPL = {};\nvar GLOBAL_MIXIN = '__global_mixin';\nvar RIOT_PREFIX = 'riot-';\nvar RIOT_TAG_IS = 'data-is';\nvar T_STRING = 'string';\nvar T_OBJECT = 'object';\nvar T_UNDEF  = 'undefined';\nvar T_FUNCTION = 'function';\nvar XLINK_NS = 'http://www.w3.org/1999/xlink';\nvar XLINK_REGEX = /^xlink:(\\w+)/;\nvar WIN = typeof window === T_UNDEF ? undefined : window;\nvar RE_SPECIAL_TAGS = /^(?:t(?:body|head|foot|[rhd])|caption|col(?:group)?|opt(?:ion|group))$/;\nvar RE_SPECIAL_TAGS_NO_OPTION = /^(?:t(?:body|head|foot|[rhd])|caption|col(?:group)?)$/;\nvar RE_RESERVED_NAMES = /^(?:_(?:item|id|parent)|update|root|(?:un)?mount|mixin|is(?:Mounted|Loop)|tags|refs|parent|opts|trigger|o(?:n|ff|ne))$/;\nvar RE_SVG_TAGS = /^(altGlyph|animate(?:Color)?|circle|clipPath|defs|ellipse|fe(?:Blend|ColorMatrix|ComponentTransfer|Composite|ConvolveMatrix|DiffuseLighting|DisplacementMap|Flood|GaussianBlur|Image|Merge|Morphology|Offset|SpecularLighting|Tile|Turbulence)|filter|font|foreignObject|g(?:lyph)?(?:Ref)?|image|line(?:arGradient)?|ma(?:rker|sk)|missing-glyph|path|pattern|poly(?:gon|line)|radialGradient|rect|stop|svg|switch|symbol|text(?:Path)?|tref|tspan|use)$/;\nvar RE_HTML_ATTRS = /([-\\w]+) ?= ?(?:\"([^\"]*)|'([^']*)|({[^}]*}))/g;\nvar RE_BOOL_ATTRS = /^(?:disabled|checked|readonly|required|allowfullscreen|auto(?:focus|play)|compact|controls|default|formnovalidate|hidden|ismap|itemscope|loop|multiple|muted|no(?:resize|shade|validate|wrap)?|open|reversed|seamless|selected|sortable|truespeed|typemustmatch)$/;\nvar IE_VERSION = (WIN && WIN.document || {}).documentMode | 0;\n\n/**\n * Check whether a DOM node must be considered a part of an svg document\n * @param   { String } name -\n * @returns { Boolean } -\n */\nfunction isSVGTag(name) {\n  return RE_SVG_TAGS.test(name)\n}\n\n/**\n * Check Check if the passed argument is undefined\n * @param   { String } value -\n * @returns { Boolean } -\n */\nfunction isBoolAttr(value) {\n  return RE_BOOL_ATTRS.test(value)\n}\n\n/**\n * Check if passed argument is a function\n * @param   { * } value -\n * @returns { Boolean } -\n */\nfunction isFunction(value) {\n  return typeof value === T_FUNCTION || false // avoid IE problems\n}\n\n/**\n * Check if passed argument is an object, exclude null\n * NOTE: use isObject(x) && !isArray(x) to excludes arrays.\n * @param   { * } value -\n * @returns { Boolean } -\n */\nfunction isObject(value) {\n  return value && typeof value === T_OBJECT // typeof null is 'object'\n}\n\n/**\n * Check if passed argument is undefined\n * @param   { * } value -\n * @returns { Boolean } -\n */\nfunction isUndefined(value) {\n  return typeof value === T_UNDEF\n}\n\n/**\n * Check if passed argument is a string\n * @param   { * } value -\n * @returns { Boolean } -\n */\nfunction isString(value) {\n  return typeof value === T_STRING\n}\n\n/**\n * Check if passed argument is empty. Different from falsy, because we dont consider 0 or false to be blank\n * @param { * } value -\n * @returns { Boolean } -\n */\nfunction isBlank(value) {\n  return isUndefined(value) || value === null || value === ''\n}\n\n/**\n * Check if passed argument is a kind of array\n * @param   { * } value -\n * @returns { Boolean } -\n */\nfunction isArray(value) {\n  return Array.isArray(value) || value instanceof Array\n}\n\n/**\n * Check whether object's property could be overridden\n * @param   { Object }  obj - source object\n * @param   { String }  key - object property\n * @returns { Boolean } -\n */\nfunction isWritable(obj, key) {\n  var descriptor = Object.getOwnPropertyDescriptor(obj, key);\n  return isUndefined(obj[key]) || descriptor && descriptor.writable\n}\n\n/**\n * Check if passed argument is a reserved name\n * @param   { String } value -\n * @returns { Boolean } -\n */\nfunction isReservedName(value) {\n  return RE_RESERVED_NAMES.test(value)\n}\n\nvar check = Object.freeze({\n\tisSVGTag: isSVGTag,\n\tisBoolAttr: isBoolAttr,\n\tisFunction: isFunction,\n\tisObject: isObject,\n\tisUndefined: isUndefined,\n\tisString: isString,\n\tisBlank: isBlank,\n\tisArray: isArray,\n\tisWritable: isWritable,\n\tisReservedName: isReservedName\n});\n\n/**\n * Shorter and fast way to select multiple nodes in the DOM\n * @param   { String } selector - DOM selector\n * @param   { Object } ctx - DOM node where the targets of our search will is located\n * @returns { Object } dom nodes found\n */\nfunction $$(selector, ctx) {\n  return (ctx || document).querySelectorAll(selector)\n}\n\n/**\n * Shorter and fast way to select a single node in the DOM\n * @param   { String } selector - unique dom selector\n * @param   { Object } ctx - DOM node where the target of our search will is located\n * @returns { Object } dom node found\n */\nfunction $(selector, ctx) {\n  return (ctx || document).querySelector(selector)\n}\n\n/**\n * Create a document fragment\n * @returns { Object } document fragment\n */\nfunction createFrag() {\n  return document.createDocumentFragment()\n}\n\n/**\n * Create a document text node\n * @returns { Object } create a text node to use as placeholder\n */\nfunction createDOMPlaceholder() {\n  return document.createTextNode('')\n}\n\n/**\n * Create a generic DOM node\n * @param   { String } name - name of the DOM node we want to create\n * @param   { Boolean } isSvg - should we use a SVG as parent node?\n * @returns { Object } DOM node just created\n */\nfunction mkEl(name, isSvg) {\n  return isSvg ?\n    document.createElementNS('http://www.w3.org/2000/svg', 'svg') :\n    document.createElement(name)\n}\n\n/**\n * Get the outer html of any DOM node SVGs included\n * @param   { Object } el - DOM node to parse\n * @returns { String } el.outerHTML\n */\nfunction getOuterHTML(el) {\n  if (el.outerHTML)\n    { return el.outerHTML }\n  // some browsers do not support outerHTML on the SVGs tags\n  else {\n    var container = mkEl('div');\n    container.appendChild(el.cloneNode(true));\n    return container.innerHTML\n  }\n}\n\n/**\n * Set the inner html of any DOM node SVGs included\n * @param { Object } container - DOM node where we'll inject new html\n * @param { String } html - html to inject\n */\nfunction setInnerHTML(container, html) {\n  if (!isUndefined(container.innerHTML))\n    { container.innerHTML = html; }\n    // some browsers do not support innerHTML on the SVGs tags\n  else {\n    var doc = new DOMParser().parseFromString(html, 'application/xml');\n    var node = container.ownerDocument.importNode(doc.documentElement, true);\n    container.appendChild(node);\n  }\n}\n\n/**\n * Remove any DOM attribute from a node\n * @param   { Object } dom - DOM node we want to update\n * @param   { String } name - name of the property we want to remove\n */\nfunction remAttr(dom, name) {\n  dom.removeAttribute(name);\n}\n\n/**\n * Get the value of any DOM attribute on a node\n * @param   { Object } dom - DOM node we want to parse\n * @param   { String } name - name of the attribute we want to get\n * @returns { String | undefined } name of the node attribute whether it exists\n */\nfunction getAttr(dom, name) {\n  return dom.getAttribute(name)\n}\n\n/**\n * Set any DOM attribute\n * @param { Object } dom - DOM node we want to update\n * @param { String } name - name of the property we want to set\n * @param { String } val - value of the property we want to set\n */\nfunction setAttr(dom, name, val) {\n  var xlink = XLINK_REGEX.exec(name);\n  if (xlink && xlink[1])\n    { dom.setAttributeNS(XLINK_NS, xlink[1], val); }\n  else\n    { dom.setAttribute(name, val); }\n}\n\n/**\n * Insert safely a tag to fix #1962 #1649\n * @param   { HTMLElement } root - children container\n * @param   { HTMLElement } curr - node to insert\n * @param   { HTMLElement } next - node that should preceed the current node inserted\n */\nfunction safeInsert(root, curr, next) {\n  root.insertBefore(curr, next.parentNode && next);\n}\n\n/**\n * Minimize risk: only zero or one _space_ between attr & value\n * @param   { String }   html - html string we want to parse\n * @param   { Function } fn - callback function to apply on any attribute found\n */\nfunction walkAttrs(html, fn) {\n  if (!html)\n    { return }\n  var m;\n  while (m = RE_HTML_ATTRS.exec(html))\n    { fn(m[1].toLowerCase(), m[2] || m[3] || m[4]); }\n}\n\n/**\n * Walk down recursively all the children tags starting dom node\n * @param   { Object }   dom - starting node where we will start the recursion\n * @param   { Function } fn - callback to transform the child node just found\n * @param   { Object }   context - fn can optionally return an object, which is passed to children\n */\nfunction walkNodes(dom, fn, context) {\n  if (dom) {\n    var res = fn(dom, context);\n    var next;\n    // stop the recursion\n    if (res === false) { return }\n\n    dom = dom.firstChild;\n\n    while (dom) {\n      next = dom.nextSibling;\n      walkNodes(dom, fn, res);\n      dom = next;\n    }\n  }\n}\n\nvar dom = Object.freeze({\n\t$$: $$,\n\t$: $,\n\tcreateFrag: createFrag,\n\tcreateDOMPlaceholder: createDOMPlaceholder,\n\tmkEl: mkEl,\n\tgetOuterHTML: getOuterHTML,\n\tsetInnerHTML: setInnerHTML,\n\tremAttr: remAttr,\n\tgetAttr: getAttr,\n\tsetAttr: setAttr,\n\tsafeInsert: safeInsert,\n\twalkAttrs: walkAttrs,\n\twalkNodes: walkNodes\n});\n\nvar styleNode;\nvar cssTextProp;\nvar byName = {};\nvar remainder = [];\n\n// skip the following code on the server\nif (WIN) {\n  styleNode = (function () {\n    // create a new style element with the correct type\n    var newNode = mkEl('style');\n    setAttr(newNode, 'type', 'text/css');\n\n    // replace any user node or insert the new one into the head\n    var userNode = $('style[type=riot]');\n    if (userNode) {\n      if (userNode.id) { newNode.id = userNode.id; }\n      userNode.parentNode.replaceChild(newNode, userNode);\n    }\n    else { document.getElementsByTagName('head')[0].appendChild(newNode); }\n\n    return newNode\n  })();\n  cssTextProp = styleNode.styleSheet;\n}\n\n/**\n * Object that will be used to inject and manage the css of every tag instance\n */\nvar styleManager = {\n  styleNode: styleNode,\n  /**\n   * Save a tag style to be later injected into DOM\n   * @param { String } css - css string\n   * @param { String } name - if it's passed we will map the css to a tagname\n   */\n  add: function add(css, name) {\n    if (name) { byName[name] = css; }\n    else { remainder.push(css); }\n  },\n  /**\n   * Inject all previously saved tag styles into DOM\n   * innerHTML seems slow: http://jsperf.com/riot-insert-style\n   */\n  inject: function inject() {\n    if (!WIN) { return }\n    var style = Object.keys(byName)\n      .map(function(k) { return byName[k] })\n      .concat(remainder).join('\\n');\n    if (cssTextProp) { cssTextProp.cssText = style; }\n    else { styleNode.innerHTML = style; }\n  }\n};\n\n/**\n * The riot template engine\n * @version v3.0.0\n */\n/**\n * riot.util.brackets\n *\n * - `brackets    ` - Returns a string or regex based on its parameter\n * - `brackets.set` - Change the current riot brackets\n *\n * @module\n */\n\n/* global riot */\n\nvar brackets = (function (UNDEF) {\n\n  var\n    REGLOB = 'g',\n\n    R_MLCOMMS = /\\/\\*[^*]*\\*+(?:[^*\\/][^*]*\\*+)*\\//g,\n\n    R_STRINGS = /\"[^\"\\\\]*(?:\\\\[\\S\\s][^\"\\\\]*)*\"|'[^'\\\\]*(?:\\\\[\\S\\s][^'\\\\]*)*'/g,\n\n    S_QBLOCKS = R_STRINGS.source + '|' +\n      /(?:\\breturn\\s+|(?:[$\\w\\)\\]]|\\+\\+|--)\\s*(\\/)(?![*\\/]))/.source + '|' +\n      /\\/(?=[^*\\/])[^[\\/\\\\]*(?:(?:\\[(?:\\\\.|[^\\]\\\\]*)*\\]|\\\\.)[^[\\/\\\\]*)*?(\\/)[gim]*/.source,\n\n    UNSUPPORTED = RegExp('[\\\\' + 'x00-\\\\x1F<>a-zA-Z0-9\\'\",;\\\\\\\\]'),\n\n    NEED_ESCAPE = /(?=[[\\]()*+?.^$|])/g,\n\n    FINDBRACES = {\n      '(': RegExp('([()])|'   + S_QBLOCKS, REGLOB),\n      '[': RegExp('([[\\\\]])|' + S_QBLOCKS, REGLOB),\n      '{': RegExp('([{}])|'   + S_QBLOCKS, REGLOB)\n    },\n\n    DEFAULT = '{ }';\n\n  var _pairs = [\n    '{', '}',\n    '{', '}',\n    /{[^}]*}/,\n    /\\\\([{}])/g,\n    /\\\\({)|{/g,\n    RegExp('\\\\\\\\(})|([[({])|(})|' + S_QBLOCKS, REGLOB),\n    DEFAULT,\n    /^\\s*{\\^?\\s*([$\\w]+)(?:\\s*,\\s*(\\S+))?\\s+in\\s+(\\S.*)\\s*}/,\n    /(^|[^\\\\]){=[\\S\\s]*?}/\n  ];\n\n  var\n    cachedBrackets = UNDEF,\n    _regex,\n    _cache = [],\n    _settings;\n\n  function _loopback (re) { return re }\n\n  function _rewrite (re, bp) {\n    if (!bp) { bp = _cache; }\n    return new RegExp(\n      re.source.replace(/{/g, bp[2]).replace(/}/g, bp[3]), re.global ? REGLOB : ''\n    )\n  }\n\n  function _create (pair) {\n    if (pair === DEFAULT) { return _pairs }\n\n    var arr = pair.split(' ');\n\n    if (arr.length !== 2 || UNSUPPORTED.test(pair)) {\n      throw new Error('Unsupported brackets \"' + pair + '\"')\n    }\n    arr = arr.concat(pair.replace(NEED_ESCAPE, '\\\\').split(' '));\n\n    arr[4] = _rewrite(arr[1].length > 1 ? /{[\\S\\s]*?}/ : _pairs[4], arr);\n    arr[5] = _rewrite(pair.length > 3 ? /\\\\({|})/g : _pairs[5], arr);\n    arr[6] = _rewrite(_pairs[6], arr);\n    arr[7] = RegExp('\\\\\\\\(' + arr[3] + ')|([[({])|(' + arr[3] + ')|' + S_QBLOCKS, REGLOB);\n    arr[8] = pair;\n    return arr\n  }\n\n  function _brackets (reOrIdx) {\n    return reOrIdx instanceof RegExp ? _regex(reOrIdx) : _cache[reOrIdx]\n  }\n\n  _brackets.split = function split (str, tmpl, _bp) {\n    // istanbul ignore next: _bp is for the compiler\n    if (!_bp) { _bp = _cache; }\n\n    var\n      parts = [],\n      match,\n      isexpr,\n      start,\n      pos,\n      re = _bp[6];\n\n    isexpr = start = re.lastIndex = 0;\n\n    while ((match = re.exec(str))) {\n\n      pos = match.index;\n\n      if (isexpr) {\n\n        if (match[2]) {\n          re.lastIndex = skipBraces(str, match[2], re.lastIndex);\n          continue\n        }\n        if (!match[3]) {\n          continue\n        }\n      }\n\n      if (!match[1]) {\n        unescapeStr(str.slice(start, pos));\n        start = re.lastIndex;\n        re = _bp[6 + (isexpr ^= 1)];\n        re.lastIndex = start;\n      }\n    }\n\n    if (str && start < str.length) {\n      unescapeStr(str.slice(start));\n    }\n\n    return parts\n\n    function unescapeStr (s) {\n      if (tmpl || isexpr) {\n        parts.push(s && s.replace(_bp[5], '$1'));\n      } else {\n        parts.push(s);\n      }\n    }\n\n    function skipBraces (s, ch, ix) {\n      var\n        match,\n        recch = FINDBRACES[ch];\n\n      recch.lastIndex = ix;\n      ix = 1;\n      while ((match = recch.exec(s))) {\n        if (match[1] &&\n          !(match[1] === ch ? ++ix : --ix)) { break }\n      }\n      return ix ? s.length : recch.lastIndex\n    }\n  };\n\n  _brackets.hasExpr = function hasExpr (str) {\n    return _cache[4].test(str)\n  };\n\n  _brackets.loopKeys = function loopKeys (expr) {\n    var m = expr.match(_cache[9]);\n\n    return m\n      ? { key: m[1], pos: m[2], val: _cache[0] + m[3].trim() + _cache[1] }\n      : { val: expr.trim() }\n  };\n\n  _brackets.array = function array (pair) {\n    return pair ? _create(pair) : _cache\n  };\n\n  function _reset (pair) {\n    if ((pair || (pair = DEFAULT)) !== _cache[8]) {\n      _cache = _create(pair);\n      _regex = pair === DEFAULT ? _loopback : _rewrite;\n      _cache[9] = _regex(_pairs[9]);\n    }\n    cachedBrackets = pair;\n  }\n\n  function _setSettings (o) {\n    var b;\n\n    o = o || {};\n    b = o.brackets;\n    Object.defineProperty(o, 'brackets', {\n      set: _reset,\n      get: function () { return cachedBrackets },\n      enumerable: true\n    });\n    _settings = o;\n    _reset(b);\n  }\n\n  Object.defineProperty(_brackets, 'settings', {\n    set: _setSettings,\n    get: function () { return _settings }\n  });\n\n  /* istanbul ignore next: in the browser riot is always in the scope */\n  _brackets.settings = typeof riot !== 'undefined' && riot.settings || {};\n  _brackets.set = _reset;\n\n  _brackets.R_STRINGS = R_STRINGS;\n  _brackets.R_MLCOMMS = R_MLCOMMS;\n  _brackets.S_QBLOCKS = S_QBLOCKS;\n\n  return _brackets\n\n})();\n\n/**\n * @module tmpl\n *\n * tmpl          - Root function, returns the template value, render with data\n * tmpl.hasExpr  - Test the existence of a expression inside a string\n * tmpl.loopKeys - Get the keys for an 'each' loop (used by `_each`)\n */\n\nvar tmpl = (function () {\n\n  var _cache = {};\n\n  function _tmpl (str, data) {\n    if (!str) { return str }\n\n    return (_cache[str] || (_cache[str] = _create(str))).call(data, _logErr)\n  }\n\n  _tmpl.hasExpr = brackets.hasExpr;\n\n  _tmpl.loopKeys = brackets.loopKeys;\n\n  // istanbul ignore next\n  _tmpl.clearCache = function () { _cache = {}; };\n\n  _tmpl.errorHandler = null;\n\n  function _logErr (err, ctx) {\n\n    err.riotData = {\n      tagName: ctx && ctx.root && ctx.root.tagName,\n      _riot_id: ctx && ctx._riot_id  //eslint-disable-line camelcase\n    };\n\n    if (_tmpl.errorHandler) { _tmpl.errorHandler(err); }\n\n    if (\n      typeof console !== 'undefined' &&\n      typeof console.error === 'function'\n    ) {\n      if (err.riotData.tagName) {\n        console.error('Riot template error thrown in the <%s> tag', err.riotData.tagName);\n      }\n      console.error(err);\n    }\n  }\n\n  function _create (str) {\n    var expr = _getTmpl(str);\n\n    if (expr.slice(0, 11) !== 'try{return ') { expr = 'return ' + expr; }\n\n    return new Function('E', expr + ';')    // eslint-disable-line no-new-func\n  }\n\n  var\n    CH_IDEXPR = String.fromCharCode(0x2057),\n    RE_CSNAME = /^(?:(-?[_A-Za-z\\xA0-\\xFF][-\\w\\xA0-\\xFF]*)|\\u2057(\\d+)~):/,\n    RE_QBLOCK = RegExp(brackets.S_QBLOCKS, 'g'),\n    RE_DQUOTE = /\\u2057/g,\n    RE_QBMARK = /\\u2057(\\d+)~/g;\n\n  function _getTmpl (str) {\n    var\n      qstr = [],\n      expr,\n      parts = brackets.split(str.replace(RE_DQUOTE, '\"'), 1);\n\n    if (parts.length > 2 || parts[0]) {\n      var i, j, list = [];\n\n      for (i = j = 0; i < parts.length; ++i) {\n\n        expr = parts[i];\n\n        if (expr && (expr = i & 1\n\n            ? _parseExpr(expr, 1, qstr)\n\n            : '\"' + expr\n                .replace(/\\\\/g, '\\\\\\\\')\n                .replace(/\\r\\n?|\\n/g, '\\\\n')\n                .replace(/\"/g, '\\\\\"') +\n              '\"'\n\n          )) { list[j++] = expr; }\n\n      }\n\n      expr = j < 2 ? list[0]\n           : '[' + list.join(',') + '].join(\"\")';\n\n    } else {\n\n      expr = _parseExpr(parts[1], 0, qstr);\n    }\n\n    if (qstr[0]) {\n      expr = expr.replace(RE_QBMARK, function (_, pos) {\n        return qstr[pos]\n          .replace(/\\r/g, '\\\\r')\n          .replace(/\\n/g, '\\\\n')\n      });\n    }\n    return expr\n  }\n\n  var\n    RE_BREND = {\n      '(': /[()]/g,\n      '[': /[[\\]]/g,\n      '{': /[{}]/g\n    };\n\n  function _parseExpr (expr, asText, qstr) {\n\n    expr = expr\n          .replace(RE_QBLOCK, function (s, div) {\n            return s.length > 2 && !div ? CH_IDEXPR + (qstr.push(s) - 1) + '~' : s\n          })\n          .replace(/\\s+/g, ' ').trim()\n          .replace(/\\ ?([[\\({},?\\.:])\\ ?/g, '$1');\n\n    if (expr) {\n      var\n        list = [],\n        cnt = 0,\n        match;\n\n      while (expr &&\n            (match = expr.match(RE_CSNAME)) &&\n            !match.index\n        ) {\n        var\n          key,\n          jsb,\n          re = /,|([[{(])|$/g;\n\n        expr = RegExp.rightContext;\n        key  = match[2] ? qstr[match[2]].slice(1, -1).trim().replace(/\\s+/g, ' ') : match[1];\n\n        while (jsb = (match = re.exec(expr))[1]) { skipBraces(jsb, re); }\n\n        jsb  = expr.slice(0, match.index);\n        expr = RegExp.rightContext;\n\n        list[cnt++] = _wrapExpr(jsb, 1, key);\n      }\n\n      expr = !cnt ? _wrapExpr(expr, asText)\n           : cnt > 1 ? '[' + list.join(',') + '].join(\" \").trim()' : list[0];\n    }\n    return expr\n\n    function skipBraces (ch, re) {\n      var\n        mm,\n        lv = 1,\n        ir = RE_BREND[ch];\n\n      ir.lastIndex = re.lastIndex;\n      while (mm = ir.exec(expr)) {\n        if (mm[0] === ch) { ++lv; }\n        else if (!--lv) { break }\n      }\n      re.lastIndex = lv ? expr.length : ir.lastIndex;\n    }\n  }\n\n  // istanbul ignore next: not both\n  var // eslint-disable-next-line max-len\n    JS_CONTEXT = '\"in this?this:' + (typeof window !== 'object' ? 'global' : 'window') + ').',\n    JS_VARNAME = /[,{][\\$\\w]+(?=:)|(^ *|[^$\\w\\.{])(?!(?:typeof|true|false|null|undefined|in|instanceof|is(?:Finite|NaN)|void|NaN|new|Date|RegExp|Math)(?![$\\w]))([$_A-Za-z][$\\w]*)/g,\n    JS_NOPROPS = /^(?=(\\.[$\\w]+))\\1(?:[^.[(]|$)/;\n\n  function _wrapExpr (expr, asText, key) {\n    var tb;\n\n    expr = expr.replace(JS_VARNAME, function (match, p, mvar, pos, s) {\n      if (mvar) {\n        pos = tb ? 0 : pos + match.length;\n\n        if (mvar !== 'this' && mvar !== 'global' && mvar !== 'window') {\n          match = p + '(\"' + mvar + JS_CONTEXT + mvar;\n          if (pos) { tb = (s = s[pos]) === '.' || s === '(' || s === '['; }\n        } else if (pos) {\n          tb = !JS_NOPROPS.test(s.slice(pos));\n        }\n      }\n      return match\n    });\n\n    if (tb) {\n      expr = 'try{return ' + expr + '}catch(e){E(e,this)}';\n    }\n\n    if (key) {\n\n      expr = (tb\n          ? 'function(){' + expr + '}.call(this)' : '(' + expr + ')'\n        ) + '?\"' + key + '\":\"\"';\n\n    } else if (asText) {\n\n      expr = 'function(v){' + (tb\n          ? expr.replace('return ', 'v=') : 'v=(' + expr + ')'\n        ) + ';return v||v===0?v:\"\"}.call(this)';\n    }\n\n    return expr\n  }\n\n  _tmpl.version = brackets.version = 'v3.0.0';\n\n  return _tmpl\n\n})();\n\n/**\n * Specialized function for looping an array-like collection with `each={}`\n * @param   { Array } list - collection of items\n * @param   {Function} fn - callback function\n * @returns { Array } the array looped\n */\nfunction each(list, fn) {\n  var len = list ? list.length : 0;\n\n  for (var i = 0, el; i < len; ++i) {\n    el = list[i];\n    // return false -> current item was removed by fn during the loop\n    if (fn(el, i) === false)\n      { i--; }\n  }\n  return list\n}\n\n/**\n * Check whether an array contains an item\n * @param   { Array } array - target array\n * @param   { * } item - item to test\n * @returns { Boolean } -\n */\nfunction contains(array, item) {\n  return ~array.indexOf(item)\n}\n\n/**\n * Convert a string containing dashes to camel case\n * @param   { String } str - input string\n * @returns { String } my-string -> myString\n */\nfunction toCamel(str) {\n  return str.replace(/-(\\w)/g, function (_, c) { return c.toUpperCase(); })\n}\n\n/**\n * Faster String startsWith alternative\n * @param   { String } str - source string\n * @param   { String } value - test string\n * @returns { Boolean } -\n */\nfunction startsWith(str, value) {\n  return str.slice(0, value.length) === value\n}\n\n/**\n * Helper function to set an immutable property\n * @param   { Object } el - object where the new property will be set\n * @param   { String } key - object key where the new property will be stored\n * @param   { * } value - value of the new property\n * @param   { Object } options - set the propery overriding the default options\n * @returns { Object } - the initial object\n */\nfunction defineProperty(el, key, value, options) {\n  Object.defineProperty(el, key, extend({\n    value: value,\n    enumerable: false,\n    writable: false,\n    configurable: true\n  }, options));\n  return el\n}\n\n/**\n * Extend any object with other properties\n * @param   { Object } src - source object\n * @returns { Object } the resulting extended object\n *\n * var obj = { foo: 'baz' }\n * extend(obj, {bar: 'bar', foo: 'bar'})\n * console.log(obj) => {bar: 'bar', foo: 'bar'}\n *\n */\nfunction extend(src) {\n  var obj, args = arguments;\n  for (var i = 1; i < args.length; ++i) {\n    if (obj = args[i]) {\n      for (var key in obj) {\n        // check if this property of the source object could be overridden\n        if (isWritable(src, key))\n          { src[key] = obj[key]; }\n      }\n    }\n  }\n  return src\n}\n\nvar misc = Object.freeze({\n\teach: each,\n\tcontains: contains,\n\ttoCamel: toCamel,\n\tstartsWith: startsWith,\n\tdefineProperty: defineProperty,\n\textend: extend\n});\n\nvar observable = function(el) {\n\n  /**\n   * Extend the original object or create a new empty one\n   * @type { Object }\n   */\n\n  el = el || {};\n\n  /**\n   * Private variables\n   */\n  var callbacks = {},\n    slice = Array.prototype.slice;\n\n  /**\n   * Public Api\n   */\n\n  // extend the el object adding the observable methods\n  Object.defineProperties(el, {\n    /**\n     * Listen to the given `event` ands\n     * execute the `callback` each time an event is triggered.\n     * @param  { String } event - event id\n     * @param  { Function } fn - callback function\n     * @returns { Object } el\n     */\n    on: {\n      value: function(event, fn) {\n        if (typeof fn == 'function')\n          { (callbacks[event] = callbacks[event] || []).push(fn); }\n        return el\n      },\n      enumerable: false,\n      writable: false,\n      configurable: false\n    },\n\n    /**\n     * Removes the given `event` listeners\n     * @param   { String } event - event id\n     * @param   { Function } fn - callback function\n     * @returns { Object } el\n     */\n    off: {\n      value: function(event, fn) {\n        if (event == '*' && !fn) { callbacks = {}; }\n        else {\n          if (fn) {\n            var arr = callbacks[event];\n            for (var i = 0, cb; cb = arr && arr[i]; ++i) {\n              if (cb == fn) { arr.splice(i--, 1); }\n            }\n          } else { delete callbacks[event]; }\n        }\n        return el\n      },\n      enumerable: false,\n      writable: false,\n      configurable: false\n    },\n\n    /**\n     * Listen to the given `event` and\n     * execute the `callback` at most once\n     * @param   { String } event - event id\n     * @param   { Function } fn - callback function\n     * @returns { Object } el\n     */\n    one: {\n      value: function(event, fn) {\n        function on() {\n          el.off(event, on);\n          fn.apply(el, arguments);\n        }\n        return el.on(event, on)\n      },\n      enumerable: false,\n      writable: false,\n      configurable: false\n    },\n\n    /**\n     * Execute all callback functions that listen to\n     * the given `event`\n     * @param   { String } event - event id\n     * @returns { Object } el\n     */\n    trigger: {\n      value: function(event) {\n        var arguments$1 = arguments;\n\n\n        // getting the arguments\n        var arglen = arguments.length - 1,\n          args = new Array(arglen),\n          fns,\n          fn,\n          i;\n\n        for (i = 0; i < arglen; i++) {\n          args[i] = arguments$1[i + 1]; // skip first argument\n        }\n\n        fns = slice.call(callbacks[event] || [], 0);\n\n        for (i = 0; fn = fns[i]; ++i) {\n          fn.apply(el, args);\n        }\n\n        if (callbacks['*'] && event != '*')\n          { el.trigger.apply(el, ['*', event].concat(args)); }\n\n        return el\n      },\n      enumerable: false,\n      writable: false,\n      configurable: false\n    }\n  });\n\n  return el\n\n};\n\nvar EVENTS_PREFIX_REGEX = /^on/;\n\n/**\n * Trigger DOM events\n * @param   { HTMLElement } dom - dom element target of the event\n * @param   { Function } handler - user function\n * @param   { Object } e - event object\n */\nfunction handleEvent(dom, handler, e) {\n  var ptag = this._parent,\n    item = this._item;\n\n  if (!item)\n    { while (ptag && !item) {\n      item = ptag._item;\n      ptag = ptag._parent;\n    } }\n\n  // override the event properties\n  if (isWritable(e, 'currentTarget')) { e.currentTarget = dom; }\n  if (isWritable(e, 'target')) { e.target = e.srcElement; }\n  if (isWritable(e, 'which')) { e.which = e.charCode || e.keyCode; }\n\n  e.item = item;\n\n  handler.call(this, e);\n\n  if (!e.preventUpdate) {\n    var p = getImmediateCustomParentTag(this);\n    // fixes #2083\n    if (p.isMounted) { p.update(); }\n  }\n}\n\n/**\n * Attach an event to a DOM node\n * @param { String } name - event name\n * @param { Function } handler - event callback\n * @param { Object } dom - dom node\n * @param { Tag } tag - tag instance\n */\nfunction setEventHandler(name, handler, dom, tag) {\n  var eventName,\n    cb = handleEvent.bind(tag, dom, handler);\n\n  if (!dom.addEventListener) {\n    dom[name] = cb;\n    return\n  }\n\n  // avoid to bind twice the same event\n  dom[name] = null;\n\n  // normalize event name\n  eventName = name.replace(EVENTS_PREFIX_REGEX, '');\n\n  // cache the callback directly on the DOM node\n  if (!dom._riotEvents) { dom._riotEvents = {}; }\n\n  if (dom._riotEvents[name])\n    { dom.removeEventListener(eventName, dom._riotEvents[name]); }\n\n  dom._riotEvents[name] = cb;\n  dom.addEventListener(eventName, cb, false);\n}\n\n/**\n * Update dynamically created data-is tags with changing expressions\n * @param { Object } expr - expression tag and expression info\n * @param { Tag } parent - parent for tag creation\n */\nfunction updateDataIs(expr, parent) {\n  var tagName = tmpl(expr.value, parent),\n    conf;\n\n  if (expr.tag && expr.tagName === tagName) {\n    expr.tag.update();\n    return\n  }\n\n  // sync _parent to accommodate changing tagnames\n  if (expr.tag) {\n    var delName = expr.value,\n      tags = expr.tag._parent.tags;\n\n    setAttr(expr.tag.root, RIOT_TAG_IS, tagName); // update for css\n    arrayishRemove(tags, delName, expr.tag);\n  }\n\n  expr.impl = __TAG_IMPL[tagName];\n  conf = {root: expr.dom, parent: parent, hasImpl: true, tagName: tagName};\n  expr.tag = initChildTag(expr.impl, conf, expr.dom.innerHTML, parent);\n  expr.tagName = tagName;\n  expr.tag.mount();\n  expr.tag.update();\n\n  // parent is the placeholder tag, not the dynamic tag so clean up\n  parent.on('unmount', function () {\n    var delName = expr.tag.opts.dataIs,\n      tags = expr.tag.parent.tags,\n      _tags = expr.tag._parent.tags;\n    arrayishRemove(tags, delName, expr.tag);\n    arrayishRemove(_tags, delName, expr.tag);\n    expr.tag.unmount();\n  });\n}\n\n/**\n * Update on single tag expression\n * @this Tag\n * @param { Object } expr - expression logic\n * @returns { undefined }\n */\nfunction updateExpression(expr) {\n  var dom = expr.dom,\n    attrName = expr.attr,\n    value = tmpl(expr.expr, this),\n    isValueAttr = attrName === 'riot-value',\n    isVirtual = expr.root && expr.root.tagName === 'VIRTUAL',\n    parent = dom && (expr.parent || dom.parentNode),\n    old;\n\n  if (expr.bool)\n    { value = value ? attrName : false; }\n  else if (isUndefined(value) || value === null)\n    { value = ''; }\n\n  if (expr._riot_id) { // if it's a tag\n    if (expr.isMounted) {\n      expr.update();\n\n    // if it hasn't been mounted yet, do that now.\n    } else {\n      expr.mount();\n\n      if (isVirtual) {\n        var frag = document.createDocumentFragment();\n        makeVirtual.call(expr, frag);\n        expr.root.parentElement.replaceChild(frag, expr.root);\n      }\n    }\n    return\n  }\n\n  old = expr.value;\n  expr.value = value;\n\n  if (expr.update) {\n    expr.update();\n    return\n  }\n\n  if (old === value) { return }\n  if (expr.isRtag && value) { return updateDataIs(expr, this) }\n  // no change, so nothing more to do\n  if (isValueAttr && dom.value === value) { return }\n\n  // textarea and text nodes have no attribute name\n  if (!attrName) {\n    // about #815 w/o replace: the browser converts the value to a string,\n    // the comparison by \"==\" does too, but not in the server\n    value += '';\n    // test for parent avoids error with invalid assignment to nodeValue\n    if (parent) {\n      // cache the parent node because somehow it will become null on IE\n      // on the next iteration\n      expr.parent = parent;\n      if (parent.tagName === 'TEXTAREA') {\n        parent.value = value;                    // #1113\n        if (!IE_VERSION) { dom.nodeValue = value; }  // #1625 IE throws here, nodeValue\n      }                                         // will be available on 'updated'\n      else { dom.nodeValue = value; }\n    }\n    return\n  }\n\n  // remove original attribute\n  if (!expr.isAttrRemoved || !value) {\n    remAttr(dom, attrName);\n    expr.isAttrRemoved = true;\n  }\n\n  // event handler\n  if (isFunction(value)) {\n    setEventHandler(attrName, value, dom, this);\n  // show / hide\n  } else if (/^(show|hide)$/.test(attrName)) {\n    if (attrName === 'hide') { value = !value; }\n    dom.style.display = value ? '' : 'none';\n  // field value\n  } else if (isValueAttr) {\n    dom.value = value;\n  // <img src=\"{ expr }\">\n  } else if (startsWith(attrName, RIOT_PREFIX) && attrName !== RIOT_TAG_IS) {\n    if (value != null)\n      { setAttr(dom, attrName.slice(RIOT_PREFIX.length), value); }\n  } else {\n    // <select> <option selected={true}> </select>\n    if (attrName === 'selected' && parent && /^(SELECT|OPTGROUP)$/.test(parent.tagName) && value != null) {\n      parent.value = dom.value;\n    } if (expr.bool) {\n      dom[attrName] = value;\n      if (!value) { return }\n    } if (value === 0 || value && typeof value !== T_OBJECT) {\n      setAttr(dom, attrName, value);\n    }\n  }\n}\n\n/**\n * Update all the expressions in a Tag instance\n * @this Tag\n * @param { Array } expressions - expression that must be re evaluated\n */\nfunction update$1$1(expressions) {\n  each(expressions, updateExpression.bind(this));\n}\n\nvar IfExpr = {\n  init: function init(dom, parentTag, expr) {\n    remAttr(dom, 'if');\n    this.parentTag = parentTag;\n    this.expr = expr;\n    this.stub = document.createTextNode('');\n    this.pristine = dom;\n\n    var p = dom.parentNode;\n    p.insertBefore(this.stub, dom);\n    p.removeChild(dom);\n\n    return this\n  },\n  update: function update$1() {\n    var newValue = tmpl(this.expr, this.parentTag);\n\n    if (newValue && !this.current) { // insert\n      this.current = this.pristine.cloneNode(true);\n      this.stub.parentNode.insertBefore(this.current, this.stub);\n\n      this.expressions = [];\n      parseExpressions.apply(this.parentTag, [this.current, this.expressions, true]);\n    } else if (!newValue && this.current) { // remove\n      unmountAll(this.expressions);\n      if (this.current._tag) {\n        this.current._tag.unmount();\n      } else if (this.current.parentNode)\n        { this.current.parentNode.removeChild(this.current); }\n      this.current = null;\n      this.expressions = [];\n    }\n\n    if (newValue) { update$1$1.call(this.parentTag, this.expressions); }\n  },\n  unmount: function unmount() {\n    unmountAll(this.expressions || []);\n    delete this.pristine;\n    delete this.parentNode;\n    delete this.stub;\n  }\n};\n\nvar RefExpr = {\n  init: function init(dom, attrName, attrValue, parent) {\n    this.dom = dom;\n    this.attr = attrName;\n    this.rawValue = attrValue;\n    this.parent = parent;\n    this.hasExp = tmpl.hasExpr(attrValue);\n    this.firstRun = true;\n\n    return this\n  },\n  update: function update() {\n    var value = this.rawValue;\n    if (this.hasExp)\n      { value = tmpl(this.rawValue, this.parent); }\n\n    // if nothing changed, we're done\n    if (!this.firstRun && value === this.value) { return }\n\n    var customParent = this.parent && getImmediateCustomParentTag(this.parent);\n\n    // if the referenced element is a custom tag, then we set the tag itself, rather than DOM\n    var tagOrDom = this.tag || this.dom;\n\n    // the name changed, so we need to remove it from the old key (if present)\n    if (!isBlank(this.value) && customParent)\n      { arrayishRemove(customParent.refs, this.value, tagOrDom); }\n\n    if (isBlank(value)) {\n      // if the value is blank, we remove it\n      remAttr(this.dom, this.attr);\n    } else {\n      // add it to the refs of parent tag (this behavior was changed >=3.0)\n      if (customParent) { arrayishAdd(customParent.refs, value, tagOrDom); }\n      // set the actual DOM attr\n      setAttr(this.dom, this.attr, value);\n    }\n    this.value = value;\n    this.firstRun = false;\n  },\n  unmount: function unmount() {\n    var tagOrDom = this.tag || this.dom;\n    var customParent = this.parent && getImmediateCustomParentTag(this.parent);\n    if (!isBlank(this.value) && customParent)\n      { arrayishRemove(customParent.refs, this.value, tagOrDom); }\n    delete this.dom;\n    delete this.parent;\n  }\n};\n\n/**\n * Convert the item looped into an object used to extend the child tag properties\n * @param   { Object } expr - object containing the keys used to extend the children tags\n * @param   { * } key - value to assign to the new object returned\n * @param   { * } val - value containing the position of the item in the array\n * @param   { Object } base - prototype object for the new item\n * @returns { Object } - new object containing the values of the original item\n *\n * The variables 'key' and 'val' are arbitrary.\n * They depend on the collection type looped (Array, Object)\n * and on the expression used on the each tag\n *\n */\nfunction mkitem(expr, key, val, base) {\n  var item = base ? Object.create(base) : {};\n  item[expr.key] = key;\n  if (expr.pos) { item[expr.pos] = val; }\n  return item\n}\n\n/**\n * Unmount the redundant tags\n * @param   { Array } items - array containing the current items to loop\n * @param   { Array } tags - array containing all the children tags\n * @param   { String } tagName - key used to identify the type of tag\n * @param   { Object } parent - parent tag to remove the child from\n */\nfunction unmountRedundant(items, tags, tagName, parent) {\n\n  var i = tags.length,\n    j = items.length,\n    t;\n\n  while (i > j) {\n    t = tags[--i];\n    tags.splice(i, 1);\n    t.unmount();\n    arrayishRemove(parent.tags, tagName, t, true);\n  }\n}\n\n/**\n * Move the nested custom tags in non custom loop tags\n * @this Tag\n * @param   { Number } i - current position of the loop tag\n */\nfunction moveNestedTags(i) {\n  var this$1 = this;\n\n  each(Object.keys(this.tags), function (tagName) {\n    var tag = this$1.tags[tagName];\n    if (isArray(tag))\n      { each(tag, function (t) {\n        moveChildTag.apply(t, [tagName, i]);\n      }); }\n    else\n      { moveChildTag.apply(tag, [tagName, i]); }\n  });\n}\n\n/**\n * Move a child tag\n * @this Tag\n * @param   { HTMLElement } root - dom node containing all the loop children\n * @param   { Tag } nextTag - instance of the next tag preceding the one we want to move\n * @param   { Boolean } isVirtual - is it a virtual tag?\n */\nfunction move(root, nextTag, isVirtual) {\n  if (isVirtual)\n    { moveVirtual.apply(this, [root, nextTag]); }\n  else\n    { safeInsert(root, this.root, nextTag.root); }\n}\n\n/**\n * Insert and mount a child tag\n * @this Tag\n * @param   { HTMLElement } root - dom node containing all the loop children\n * @param   { Tag } nextTag - instance of the next tag preceding the one we want to insert\n * @param   { Boolean } isVirtual - is it a virtual tag?\n */\nfunction insert(root, nextTag, isVirtual) {\n  if (isVirtual)\n    { makeVirtual.apply(this, [root, nextTag]); }\n  else\n    { safeInsert(root, this.root, nextTag.root); }\n}\n\n/**\n * Append a new tag into the DOM\n * @this Tag\n * @param   { HTMLElement } root - dom node containing all the loop children\n * @param   { Boolean } isVirtual - is it a virtual tag?\n */\nfunction append(root, isVirtual) {\n  if (isVirtual)\n    { makeVirtual.call(this, root); }\n  else\n    { root.appendChild(this.root); }\n}\n\n/**\n * Manage tags having the 'each'\n * @param   { HTMLElement } dom - DOM node we need to loop\n * @param   { Tag } parent - parent tag instance where the dom node is contained\n * @param   { String } expr - string contained in the 'each' attribute\n * @returns { Object } expression object for this each loop\n */\nfunction _each(dom, parent, expr) {\n\n  // remove the each property from the original tag\n  remAttr(dom, 'each');\n\n  var mustReorder = typeof getAttr(dom, 'no-reorder') !== T_STRING || remAttr(dom, 'no-reorder'),\n    tagName = getTagName(dom),\n    impl = __TAG_IMPL[tagName] || { tmpl: getOuterHTML(dom) },\n    useRoot = RE_SPECIAL_TAGS.test(tagName),\n    root = dom.parentNode,\n    ref = createDOMPlaceholder(),\n    child = getTag(dom),\n    ifExpr = getAttr(dom, 'if'),\n    tags = [],\n    oldItems = [],\n    hasKeys,\n    isLoop = true,\n    isAnonymous = !__TAG_IMPL[tagName],\n    isVirtual = dom.tagName === 'VIRTUAL';\n\n  // parse the each expression\n  expr = tmpl.loopKeys(expr);\n  expr.isLoop = true;\n\n  if (ifExpr) { remAttr(dom, 'if'); }\n\n  // insert a marked where the loop tags will be injected\n  root.insertBefore(ref, dom);\n  root.removeChild(dom);\n\n  expr.update = function updateEach() {\n\n    // get the new items collection\n    var items = tmpl(expr.val, parent),\n      parentNode,\n      frag,\n      placeholder;\n\n\n    root = ref.parentNode;\n\n    if (parentNode) {\n      placeholder = createDOMPlaceholder('');\n      parentNode.insertBefore(placeholder, root);\n      parentNode.removeChild(root);\n    } else {\n      frag = createFrag();\n    }\n\n    // object loop. any changes cause full redraw\n    if (!isArray(items)) {\n      hasKeys = items || false;\n      items = hasKeys ?\n        Object.keys(items).map(function (key) {\n          return mkitem(expr, items[key], key)\n        }) : [];\n    } else {\n      hasKeys = false;\n    }\n\n    if (ifExpr) {\n      items = items.filter(function(item, i) {\n        if (expr.key) {\n          return !!tmpl(ifExpr, mkitem(expr, item, i, parent))\n        }\n        // in case it's not a keyed loop\n        // we test the validity of the if expression against\n        // the item and the parent\n        return !!tmpl(ifExpr, parent) || !!tmpl(ifExpr, item)\n      });\n    }\n\n    // loop all the new items\n    each(items, function(item, i) {\n      // reorder only if the items are objects\n      var\n        _mustReorder = mustReorder && typeof item === T_OBJECT && !hasKeys,\n        oldPos = oldItems.indexOf(item),\n        pos = ~oldPos && _mustReorder ? oldPos : i,\n        // does a tag exist in this position?\n        tag = tags[pos];\n\n      item = !hasKeys && expr.key ? mkitem(expr, item, i) : item;\n\n      // new tag\n      if (\n        !_mustReorder && !tag // with no-reorder we just update the old tags\n        ||\n        _mustReorder && !~oldPos // by default we always try to reorder the DOM elements\n      ) {\n\n        var mustAppend = i === tags.length;\n\n        tag = new Tag$$1(impl, {\n          parent: parent,\n          isLoop: isLoop,\n          isAnonymous: isAnonymous,\n          root: useRoot ? root : dom.cloneNode(),\n          item: item\n        }, dom.innerHTML);\n\n        // mount the tag\n        tag.mount();\n\n        if (mustAppend)\n          { append.apply(tag, [frag || root, isVirtual]); }\n        else\n          { insert.apply(tag, [root, tags[i], isVirtual]); }\n\n        if (!mustAppend) { oldItems.splice(i, 0, item); }\n        tags.splice(i, 0, tag);\n        if (child) { arrayishAdd(parent.tags, tagName, tag, true); }\n        pos = i; // handled here so no move\n      } else { tag.update(item); }\n\n      // reorder the tag if it's not located in its previous position\n      if (pos !== i && _mustReorder) {\n        // #closes 2040\n        if (contains(items, oldItems[i])) {\n          move.apply(tag, [root, tags[i], isVirtual]);\n        }\n        // update the position attribute if it exists\n        if (expr.pos) { tag[expr.pos] = i; }\n        // move the old tag instance\n        tags.splice(i, 0, tags.splice(pos, 1)[0]);\n        // move the old item\n        oldItems.splice(i, 0, oldItems.splice(pos, 1)[0]);\n        // if the loop tags are not custom\n        // we need to move all their custom tags into the right position\n        if (!child && tag.tags) { moveNestedTags.call(tag, i); }\n      }\n\n      // cache the original item to use it in the events bound to this node\n      // and its children\n      tag._item = item;\n      // cache the real parent tag internally\n      defineProperty(tag, '_parent', parent);\n    });\n\n    // remove the redundant tags\n    unmountRedundant(items, tags, tagName, parent);\n\n    // clone the items array\n    oldItems = items.slice();\n\n    if (frag) {\n      root.insertBefore(frag, ref);\n    } else {\n      parentNode.insertBefore(root, placeholder);\n      parentNode.removeChild(placeholder);\n    }\n\n  };\n\n  expr.unmount = function() {\n    each(tags, function(t) { t.unmount(); });\n  };\n\n  return expr\n}\n\n/**\n * Walk the tag DOM to detect the expressions to evaluate\n * @this Tag\n * @param   { HTMLElement } root - root tag where we will start digging the expressions\n * @param   { Array } expressions - empty array where the expressions will be added\n * @param   { Boolean } mustIncludeRoot - flag to decide whether the root must be parsed as well\n * @returns { Object } an object containing the root noode and the dom tree\n */\nfunction parseExpressions(root, expressions, mustIncludeRoot) {\n  var this$1 = this;\n\n  var tree = {parent: {children: expressions}};\n\n  walkNodes(root, function (dom, ctx) {\n    var type = dom.nodeType, parent = ctx.parent, attr, expr, tagImpl;\n    if (!mustIncludeRoot && dom === root) { return {parent: parent} }\n\n    // text node\n    if (type === 3 && dom.parentNode.tagName !== 'STYLE' && tmpl.hasExpr(dom.nodeValue))\n      { parent.children.push({dom: dom, expr: dom.nodeValue}); }\n\n    if (type !== 1) { return ctx } // not an element\n\n    // loop. each does it's own thing (for now)\n    if (attr = getAttr(dom, 'each')) {\n      parent.children.push(_each(dom, this$1, attr));\n      return false\n    }\n\n    // if-attrs become the new parent. Any following expressions (either on the current\n    // element, or below it) become children of this expression.\n    if (attr = getAttr(dom, 'if')) {\n      parent.children.push(Object.create(IfExpr).init(dom, this$1, attr));\n      return false\n    }\n\n    if (expr = getAttr(dom, RIOT_TAG_IS)) {\n      if (tmpl.hasExpr(expr)) {\n        parent.children.push({isRtag: true, expr: expr, dom: dom});\n        return false\n      }\n    }\n\n    // if this is a tag, stop traversing here.\n    // we ignore the root, since parseExpressions is called while we're mounting that root\n    tagImpl = getTag(dom);\n    if (tagImpl && (dom !== root || mustIncludeRoot)) {\n      var conf = {root: dom, parent: this$1, hasImpl: true};\n      parent.children.push(initChildTag(tagImpl, conf, dom.innerHTML, this$1));\n      return false\n    }\n\n    // attribute expressions\n    parseAttributes.apply(this$1, [dom, dom.attributes, function(attr, expr) {\n      if (!expr) { return }\n      parent.children.push(expr);\n    }]);\n\n    // whatever the parent is, all child elements get the same parent.\n    // If this element had an if-attr, that's the parent for all child elements\n    return {parent: parent}\n  }, tree);\n\n  return { tree: tree, root: root }\n}\n\n/**\n * Calls `fn` for every attribute on an element. If that attr has an expression,\n * it is also passed to fn.\n * @this Tag\n * @param   { HTMLElement } dom - dom node to parse\n * @param   { Array } attrs - array of attributes\n * @param   { Function } fn - callback to exec on any iteration\n */\nfunction parseAttributes(dom, attrs, fn) {\n  var this$1 = this;\n\n  each(attrs, function (attr) {\n    var name = attr.name, bool = isBoolAttr(name), expr;\n\n    if (~['ref', 'data-ref'].indexOf(name)) {\n      expr =  Object.create(RefExpr).init(dom, name, attr.value, this$1);\n    } else if (tmpl.hasExpr(attr.value)) {\n      expr = {dom: dom, expr: attr.value, attr: attr.name, bool: bool};\n    }\n\n    fn(attr, expr);\n  });\n}\n\n/*\n  Includes hacks needed for the Internet Explorer version 9 and below\n  See: http://kangax.github.io/compat-table/es5/#ie8\n       http://codeplanet.io/dropping-ie8/\n*/\n\nvar reHasYield  = /<yield\\b/i;\nvar reYieldAll  = /<yield\\s*(?:\\/>|>([\\S\\s]*?)<\\/yield\\s*>|>)/ig;\nvar reYieldSrc  = /<yield\\s+to=['\"]([^'\">]*)['\"]\\s*>([\\S\\s]*?)<\\/yield\\s*>/ig;\nvar reYieldDest = /<yield\\s+from=['\"]?([-\\w]+)['\"]?\\s*(?:\\/>|>([\\S\\s]*?)<\\/yield\\s*>)/ig;\nvar rootEls = { tr: 'tbody', th: 'tr', td: 'tr', col: 'colgroup' };\nvar tblTags = IE_VERSION && IE_VERSION < 10 ? RE_SPECIAL_TAGS : RE_SPECIAL_TAGS_NO_OPTION;\nvar GENERIC = 'div';\n\n\n/*\n  Creates the root element for table or select child elements:\n  tr/th/td/thead/tfoot/tbody/caption/col/colgroup/option/optgroup\n*/\nfunction specialTags(el, tmpl, tagName) {\n\n  var\n    select = tagName[0] === 'o',\n    parent = select ? 'select>' : 'table>';\n\n  // trim() is important here, this ensures we don't have artifacts,\n  // so we can check if we have only one element inside the parent\n  el.innerHTML = '<' + parent + tmpl.trim() + '</' + parent;\n  parent = el.firstChild;\n\n  // returns the immediate parent if tr/th/td/col is the only element, if not\n  // returns the whole tree, as this can include additional elements\n  if (select) {\n    parent.selectedIndex = -1;  // for IE9, compatible w/current riot behavior\n  } else {\n    // avoids insertion of cointainer inside container (ex: tbody inside tbody)\n    var tname = rootEls[tagName];\n    if (tname && parent.childElementCount === 1) { parent = $(tname, parent); }\n  }\n  return parent\n}\n\n/*\n  Replace the yield tag from any tag template with the innerHTML of the\n  original tag in the page\n*/\nfunction replaceYield(tmpl, html) {\n  // do nothing if no yield\n  if (!reHasYield.test(tmpl)) { return tmpl }\n\n  // be careful with #1343 - string on the source having `$1`\n  var src = {};\n\n  html = html && html.replace(reYieldSrc, function (_, ref, text) {\n    src[ref] = src[ref] || text;   // preserve first definition\n    return ''\n  }).trim();\n\n  return tmpl\n    .replace(reYieldDest, function (_, ref, def) {  // yield with from - to attrs\n      return src[ref] || def || ''\n    })\n    .replace(reYieldAll, function (_, def) {        // yield without any \"from\"\n      return html || def || ''\n    })\n}\n\n/**\n * Creates a DOM element to wrap the given content. Normally an `DIV`, but can be\n * also a `TABLE`, `SELECT`, `TBODY`, `TR`, or `COLGROUP` element.\n *\n * @param   { String } tmpl  - The template coming from the custom tag definition\n * @param   { String } html - HTML content that comes from the DOM element where you\n *           will mount the tag, mostly the original tag in the page\n * @param   { Boolean } checkSvg - flag needed to know if we need to force the svg rendering in case of loop nodes\n * @returns { HTMLElement } DOM element with _tmpl_ merged through `YIELD` with the _html_.\n */\nfunction mkdom(tmpl, html, checkSvg) {\n  var match   = tmpl && tmpl.match(/^\\s*<([-\\w]+)/),\n    tagName = match && match[1].toLowerCase(),\n    el = mkEl(GENERIC, checkSvg && isSVGTag(tagName));\n\n  // replace all the yield tags with the tag inner html\n  tmpl = replaceYield(tmpl, html);\n\n  /* istanbul ignore next */\n  if (tblTags.test(tagName))\n    { el = specialTags(el, tmpl, tagName); }\n  else\n    { setInnerHTML(el, tmpl); }\n\n  el.stub = true;\n\n  return el\n}\n\n/**\n * Another way to create a riot tag a bit more es6 friendly\n * @param { HTMLElement } el - tag DOM selector or DOM node/s\n * @param { Object } opts - tag logic\n * @returns { Tag } new riot tag instance\n */\nfunction Tag$1(el, opts) {\n  // get the tag properties from the class constructor\n  var ref = this;\n  var name = ref.name;\n  var tmpl = ref.tmpl;\n  var css = ref.css;\n  var attrs = ref.attrs;\n  var onCreate = ref.onCreate;\n  // register a new tag and cache the class prototype\n  if (!__TAG_IMPL[name]) {\n    tag$$1(name, tmpl, css, attrs, onCreate);\n    // cache the class constructor\n    __TAG_IMPL[name].class = this.constructor;\n  }\n\n  // mount the tag using the class instance\n  mountTo(el, name, opts, this);\n  // inject the component css\n  if (css) { styleManager.inject(); }\n\n  return this\n}\n\n/**\n * Create a new riot tag implementation\n * @param   { String }   name - name/id of the new riot tag\n * @param   { String }   tmpl - tag template\n * @param   { String }   css - custom tag css\n * @param   { String }   attrs - root tag attributes\n * @param   { Function } fn - user function\n * @returns { String } name/id of the tag just created\n */\nfunction tag$$1(name, tmpl, css, attrs, fn) {\n  if (isFunction(attrs)) {\n    fn = attrs;\n\n    if (/^[\\w\\-]+\\s?=/.test(css)) {\n      attrs = css;\n      css = '';\n    } else\n      { attrs = ''; }\n  }\n\n  if (css) {\n    if (isFunction(css))\n      { fn = css; }\n    else\n      { styleManager.add(css); }\n  }\n\n  name = name.toLowerCase();\n  __TAG_IMPL[name] = { name: name, tmpl: tmpl, attrs: attrs, fn: fn };\n\n  return name\n}\n\n/**\n * Create a new riot tag implementation (for use by the compiler)\n * @param   { String }   name - name/id of the new riot tag\n * @param   { String }   tmpl - tag template\n * @param   { String }   css - custom tag css\n * @param   { String }   attrs - root tag attributes\n * @param   { Function } fn - user function\n * @returns { String } name/id of the tag just created\n */\nfunction tag2$$1(name, tmpl, css, attrs, fn) {\n  if (css)\n    { styleManager.add(css, name); }\n\n  var exists = !!__TAG_IMPL[name];\n  __TAG_IMPL[name] = { name: name, tmpl: tmpl, attrs: attrs, fn: fn };\n\n  if (exists && util.hotReloader)\n    { util.hotReloader(name); }\n\n  return name\n}\n\n/**\n * Mount a tag using a specific tag implementation\n * @param   { * } selector - tag DOM selector or DOM node/s\n * @param   { String } tagName - tag implementation name\n * @param   { Object } opts - tag logic\n * @returns { Array } new tags instances\n */\nfunction mount$$1(selector, tagName, opts) {\n  var tags = [];\n\n  function pushTagsTo(root) {\n    if (root.tagName) {\n      var riotTag = getAttr(root, RIOT_TAG_IS);\n\n      // have tagName? force riot-tag to be the same\n      if (tagName && riotTag !== tagName) {\n        riotTag = tagName;\n        setAttr(root, RIOT_TAG_IS, tagName);\n      }\n\n      var tag$$1 = mountTo(root, riotTag || root.tagName.toLowerCase(), opts);\n\n      if (tag$$1)\n        { tags.push(tag$$1); }\n    } else if (root.length)\n      { each(root, pushTagsTo); } // assume nodeList\n  }\n\n  // inject styles into DOM\n  styleManager.inject();\n\n  if (isObject(tagName)) {\n    opts = tagName;\n    tagName = 0;\n  }\n\n  var elem;\n  var allTags;\n\n  // crawl the DOM to find the tag\n  if (isString(selector)) {\n    selector = selector === '*' ?\n      // select all registered tags\n      // & tags found with the riot-tag attribute set\n      allTags = selectTags() :\n      // or just the ones named like the selector\n      selector + selectTags(selector.split(/, */));\n\n    // make sure to pass always a selector\n    // to the querySelectorAll function\n    elem = selector ? $$(selector) : [];\n  }\n  else\n    // probably you have passed already a tag or a NodeList\n    { elem = selector; }\n\n  // select all the registered and mount them inside their root elements\n  if (tagName === '*') {\n    // get all custom tags\n    tagName = allTags || selectTags();\n    // if the root els it's just a single tag\n    if (elem.tagName)\n      { elem = $$(tagName, elem); }\n    else {\n      // select all the children for all the different root elements\n      var nodeList = [];\n\n      each(elem, function (_el) { return nodeList.push($$(tagName, _el)); });\n\n      elem = nodeList;\n    }\n    // get rid of the tagName\n    tagName = 0;\n  }\n\n  pushTagsTo(elem);\n\n  return tags\n}\n\n// Create a mixin that could be globally shared across all the tags\nvar mixins = {};\nvar globals = mixins[GLOBAL_MIXIN] = {};\nvar _id = 0;\n\n/**\n * Create/Return a mixin by its name\n * @param   { String }  name - mixin name (global mixin if object)\n * @param   { Object }  mix - mixin logic\n * @param   { Boolean } g - is global?\n * @returns { Object }  the mixin logic\n */\nfunction mixin$$1(name, mix, g) {\n  // Unnamed global\n  if (isObject(name)) {\n    mixin$$1((\"__unnamed_\" + (_id++)), name, true);\n    return\n  }\n\n  var store = g ? globals : mixins;\n\n  // Getter\n  if (!mix) {\n    if (isUndefined(store[name]))\n      { throw new Error('Unregistered mixin: ' + name) }\n\n    return store[name]\n  }\n\n  // Setter\n  store[name] = isFunction(mix) ?\n    extend(mix.prototype, store[name] || {}) && mix :\n    extend(store[name] || {}, mix);\n}\n\n/**\n * Update all the tags instances created\n * @returns { Array } all the tags instances\n */\nfunction update$2() {\n  return each(__TAGS_CACHE, function (tag$$1) { return tag$$1.update(); })\n}\n\nfunction unregister$$1(name) {\n  delete __TAG_IMPL[name];\n}\n\n// counter to give a unique id to all the Tag instances\nvar __uid = 0;\n\n/**\n * We need to update opts for this tag. That requires updating the expressions\n * in any attributes on the tag, and then copying the result onto opts.\n * @this Tag\n * @param   {Boolean} isLoop - is it a loop tag?\n * @param   { Tag }  parent - parent tag node\n * @param   { Boolean }  isAnonymous - is it a tag without any impl? (a tag not registered)\n * @param   { Object }  opts - tag options\n * @param   { Array }  instAttrs - tag attributes array\n */\nfunction updateOpts(isLoop, parent, isAnonymous, opts, instAttrs) {\n  // isAnonymous `each` tags treat `dom` and `root` differently. In this case\n  // (and only this case) we don't need to do updateOpts, because the regular parse\n  // will update those attrs. Plus, isAnonymous tags don't need opts anyway\n  if (isLoop && isAnonymous) { return }\n\n  var ctx = !isAnonymous && isLoop ? this : parent || this;\n  each(instAttrs, function (attr) {\n    if (attr.expr) { update$1$1.call(ctx, [attr.expr]); }\n    opts[toCamel(attr.name)] = attr.expr ? attr.expr.value : attr.value;\n  });\n}\n\n\n/**\n * Tag class\n * @constructor\n * @param { Object } impl - it contains the tag template, and logic\n * @param { Object } conf - tag options\n * @param { String } innerHTML - html that eventually we need to inject in the tag\n */\nfunction Tag$$1(impl, conf, innerHTML) {\n\n  var opts = extend({}, conf.opts),\n    parent = conf.parent,\n    isLoop = conf.isLoop,\n    isAnonymous = conf.isAnonymous,\n    item = cleanUpData(conf.item),\n    instAttrs = [], // All attributes on the Tag when it's first parsed\n    implAttrs = [], // expressions on this type of Tag\n    expressions = [],\n    root = conf.root,\n    tagName = conf.tagName || getTagName(root),\n    isVirtual = tagName === 'virtual',\n    propsInSyncWithParent = [],\n    dom;\n\n  // make this tag observable\n  observable(this);\n  // only call unmount if we have a valid __TAG_IMPL (has name property)\n  if (impl.name && root._tag) { root._tag.unmount(true); }\n\n  // not yet mounted\n  this.isMounted = false;\n  root.isLoop = isLoop;\n\n  defineProperty(this, '_internal', {\n    isAnonymous: isAnonymous,\n    instAttrs: instAttrs,\n    innerHTML: innerHTML,\n    // these vars will be needed only for the virtual tags\n    virts: [],\n    tail: null,\n    head: null\n  });\n\n  // create a unique id to this tag\n  // it could be handy to use it also to improve the virtual dom rendering speed\n  defineProperty(this, '_riot_id', ++__uid); // base 1 allows test !t._riot_id\n\n  extend(this, { parent: parent, root: root, opts: opts }, item);\n  // protect the \"tags\" and \"refs\" property from being overridden\n  defineProperty(this, 'tags', {});\n  defineProperty(this, 'refs', {});\n\n  dom = mkdom(impl.tmpl, innerHTML, isLoop);\n\n  /**\n   * Update the tag expressions and options\n   * @param   { * }  data - data we want to use to extend the tag properties\n   * @returns { Tag } the current tag instance\n   */\n  defineProperty(this, 'update', function tagUpdate(data) {\n    if (isFunction(this.shouldUpdate) && !this.shouldUpdate(data)) { return this }\n\n    // make sure the data passed will not override\n    // the component core methods\n    data = cleanUpData(data);\n\n    // inherit properties from the parent, but only for isAnonymous tags\n    if (isLoop && isAnonymous) { inheritFrom.apply(this, [this.parent, propsInSyncWithParent]); }\n    extend(this, data);\n    updateOpts.apply(this, [isLoop, parent, isAnonymous, opts, instAttrs]);\n    if (this.isMounted) { this.trigger('update', data); }\n    update$1$1.call(this, expressions);\n    if (this.isMounted) { this.trigger('updated'); }\n\n    return this\n\n  }.bind(this));\n\n  /**\n   * Add a mixin to this tag\n   * @returns { Tag } the current tag instance\n   */\n  defineProperty(this, 'mixin', function tagMixin() {\n    var this$1 = this;\n\n    each(arguments, function (mix) {\n      var instance,\n        props = [],\n        obj;\n\n      mix = isString(mix) ? mixin$$1(mix) : mix;\n\n      // check if the mixin is a function\n      if (isFunction(mix)) {\n        // create the new mixin instance\n        instance = new mix();\n      } else { instance = mix; }\n\n      var proto = Object.getPrototypeOf(instance);\n\n      // build multilevel prototype inheritance chain property list\n      do { props = props.concat(Object.getOwnPropertyNames(obj || instance)); }\n      while (obj = Object.getPrototypeOf(obj || instance))\n\n      // loop the keys in the function prototype or the all object keys\n      each(props, function (key) {\n        // bind methods to this\n        // allow mixins to override other properties/parent mixins\n        if (key !== 'init') {\n          // check for getters/setters\n          var descriptor = Object.getOwnPropertyDescriptor(instance, key) || Object.getOwnPropertyDescriptor(proto, key);\n          var hasGetterSetter = descriptor && (descriptor.get || descriptor.set);\n\n          // apply method only if it does not already exist on the instance\n          if (!this$1.hasOwnProperty(key) && hasGetterSetter) {\n            Object.defineProperty(this$1, key, descriptor);\n          } else {\n            this$1[key] = isFunction(instance[key]) ?\n              instance[key].bind(this$1) :\n              instance[key];\n          }\n        }\n      });\n\n      // init method will be called automatically\n      if (instance.init)\n        { instance.init.bind(this$1)(); }\n    });\n    return this\n  }.bind(this));\n\n  /**\n   * Mount the current tag instance\n   * @returns { Tag } the current tag instance\n   */\n  defineProperty(this, 'mount', function tagMount() {\n    var this$1 = this;\n\n    root._tag = this; // keep a reference to the tag just created\n\n    // Read all the attrs on this instance. This give us the info we need for updateOpts\n    parseAttributes.apply(parent, [root, root.attributes, function (attr, expr) {\n      if (!isAnonymous && RefExpr.isPrototypeOf(expr)) { expr.tag = this$1; }\n      attr.expr = expr;\n      instAttrs.push(attr);\n    }]);\n\n    // update the root adding custom attributes coming from the compiler\n    implAttrs = [];\n    walkAttrs(impl.attrs, function (k, v) { implAttrs.push({name: k, value: v}); });\n    parseAttributes.apply(this, [root, implAttrs, function (attr, expr) {\n      if (expr) { expressions.push(expr); }\n      else { setAttr(root, attr.name, attr.value); }\n    }]);\n\n    // children in loop should inherit from true parent\n    if (this._parent && isAnonymous) { inheritFrom.apply(this, [this._parent, propsInSyncWithParent]); }\n\n    // initialiation\n    updateOpts.apply(this, [isLoop, parent, isAnonymous, opts, instAttrs]);\n\n    // add global mixins\n    var globalMixin = mixin$$1(GLOBAL_MIXIN);\n\n    if (globalMixin) {\n      for (var i in globalMixin) {\n        if (globalMixin.hasOwnProperty(i)) {\n          this$1.mixin(globalMixin[i]);\n        }\n      }\n    }\n\n    if (impl.fn) { impl.fn.call(this, opts); }\n\n    this.trigger('before-mount');\n\n    // parse layout after init. fn may calculate args for nested custom tags\n    parseExpressions.apply(this, [dom, expressions, false]);\n\n    this.update(item);\n\n    if (isLoop && isAnonymous) {\n      // update the root attribute for the looped elements\n      this.root = root = dom.firstChild;\n    } else {\n      while (dom.firstChild) { root.appendChild(dom.firstChild); }\n      if (root.stub) { root = parent.root; }\n    }\n\n    defineProperty(this, 'root', root);\n    this.isMounted = true;\n\n    // if it's not a child tag we can trigger its mount event\n    if (!this.parent || this.parent.isMounted) {\n      this.trigger('mount');\n    }\n    // otherwise we need to wait that the parent event gets triggered\n    else { this.parent.one('mount', function () {\n      this$1.trigger('mount');\n    }); }\n\n    return this\n\n  }.bind(this));\n\n  /**\n   * Unmount the tag instance\n   * @param { Boolean } mustKeepRoot - if it's true the root node will not be removed\n   * @returns { Tag } the current tag instance\n   */\n  defineProperty(this, 'unmount', function tagUnmount(mustKeepRoot) {\n    var this$1 = this;\n\n    var el = this.root,\n      p = el.parentNode,\n      ptag,\n      tagIndex = __TAGS_CACHE.indexOf(this);\n\n    this.trigger('before-unmount');\n\n    // remove this tag instance from the global virtualDom variable\n    if (~tagIndex)\n      { __TAGS_CACHE.splice(tagIndex, 1); }\n\n    if (p) {\n      if (parent) {\n        ptag = getImmediateCustomParentTag(parent);\n\n        if (isVirtual) {\n          Object.keys(this.tags).forEach(function (tagName) {\n            arrayishRemove(ptag.tags, tagName, this$1.tags[tagName]);\n          });\n        } else {\n          arrayishRemove(ptag.tags, tagName, this);\n        }\n      } else {\n        while (el.firstChild) { el.removeChild(el.firstChild); }\n      }\n\n      if (!mustKeepRoot) {\n        p.removeChild(el);\n      } else {\n        // the riot-tag and the data-is attributes aren't needed anymore, remove them\n        remAttr(p, RIOT_TAG_IS);\n      }\n    }\n\n    if (this._internal.virts) {\n      each(this._internal.virts, function (v) {\n        if (v.parentNode) { v.parentNode.removeChild(v); }\n      });\n    }\n\n    // allow expressions to unmount themselves\n    unmountAll(expressions);\n    each(instAttrs, function (a) { return a.expr && a.expr.unmount && a.expr.unmount(); });\n\n    this.trigger('unmount');\n    this.off('*');\n    this.isMounted = false;\n\n    delete this.root._tag;\n\n    return this\n\n  }.bind(this));\n}\n\n/**\n * Detect the tag implementation by a DOM node\n * @param   { Object } dom - DOM node we need to parse to get its tag implementation\n * @returns { Object } it returns an object containing the implementation of a custom tag (template and boot function)\n */\nfunction getTag(dom) {\n  return dom.tagName && __TAG_IMPL[getAttr(dom, RIOT_TAG_IS) ||\n    getAttr(dom, RIOT_TAG_IS) || dom.tagName.toLowerCase()]\n}\n\n/**\n * Inherit properties from a target tag instance\n * @this Tag\n * @param   { Tag } target - tag where we will inherit properties\n * @param   { Array } propsInSyncWithParent - array of properties to sync with the target\n */\nfunction inheritFrom(target, propsInSyncWithParent) {\n  var this$1 = this;\n\n  each(Object.keys(target), function (k) {\n    // some properties must be always in sync with the parent tag\n    var mustSync = !isReservedName(k) && contains(propsInSyncWithParent, k);\n\n    if (isUndefined(this$1[k]) || mustSync) {\n      // track the property to keep in sync\n      // so we can keep it updated\n      if (!mustSync) { propsInSyncWithParent.push(k); }\n      this$1[k] = target[k];\n    }\n  });\n}\n\n/**\n * Move the position of a custom tag in its parent tag\n * @this Tag\n * @param   { String } tagName - key where the tag was stored\n * @param   { Number } newPos - index where the new tag will be stored\n */\nfunction moveChildTag(tagName, newPos) {\n  var parent = this.parent,\n    tags;\n  // no parent no move\n  if (!parent) { return }\n\n  tags = parent.tags[tagName];\n\n  if (isArray(tags))\n    { tags.splice(newPos, 0, tags.splice(tags.indexOf(this), 1)[0]); }\n  else { arrayishAdd(parent.tags, tagName, this); }\n}\n\n/**\n * Create a new child tag including it correctly into its parent\n * @param   { Object } child - child tag implementation\n * @param   { Object } opts - tag options containing the DOM node where the tag will be mounted\n * @param   { String } innerHTML - inner html of the child node\n * @param   { Object } parent - instance of the parent tag including the child custom tag\n * @returns { Object } instance of the new child tag just created\n */\nfunction initChildTag(child, opts, innerHTML, parent) {\n  var tag = new Tag$$1(child, opts, innerHTML),\n    tagName = opts.tagName || getTagName(opts.root, true),\n    ptag = getImmediateCustomParentTag(parent);\n  // fix for the parent attribute in the looped elements\n  tag.parent = ptag;\n  // store the real parent tag\n  // in some cases this could be different from the custom parent tag\n  // for example in nested loops\n  tag._parent = parent;\n\n  // add this tag to the custom parent tag\n  arrayishAdd(ptag.tags, tagName, tag);\n\n  // and also to the real parent tag\n  if (ptag !== parent)\n    { arrayishAdd(parent.tags, tagName, tag); }\n\n  // empty the child node once we got its template\n  // to avoid that its children get compiled multiple times\n  opts.root.innerHTML = '';\n\n  return tag\n}\n\n/**\n * Loop backward all the parents tree to detect the first custom parent tag\n * @param   { Object } tag - a Tag instance\n * @returns { Object } the instance of the first custom parent tag found\n */\nfunction getImmediateCustomParentTag(tag) {\n  var ptag = tag;\n  while (ptag._internal.isAnonymous) {\n    if (!ptag.parent) { break }\n    ptag = ptag.parent;\n  }\n  return ptag\n}\n\n/**\n * Trigger the unmount method on all the expressions\n * @param   { Array } expressions - DOM expressions\n */\nfunction unmountAll(expressions) {\n  each(expressions, function(expr) {\n    if (expr instanceof Tag$$1) { expr.unmount(true); }\n    else if (expr.unmount) { expr.unmount(); }\n  });\n}\n\n/**\n * Get the tag name of any DOM node\n * @param   { Object } dom - DOM node we want to parse\n * @param   { Boolean } skipDataIs - hack to ignore the data-is attribute when attaching to parent\n * @returns { String } name to identify this dom node in riot\n */\nfunction getTagName(dom, skipDataIs) {\n  var child = getTag(dom),\n    namedTag = !skipDataIs && getAttr(dom, RIOT_TAG_IS);\n  return namedTag && !tmpl.hasExpr(namedTag) ?\n                namedTag :\n              child ? child.name : dom.tagName.toLowerCase()\n}\n\n/**\n * With this function we avoid that the internal Tag methods get overridden\n * @param   { Object } data - options we want to use to extend the tag instance\n * @returns { Object } clean object without containing the riot internal reserved words\n */\nfunction cleanUpData(data) {\n  if (!(data instanceof Tag$$1) && !(data && typeof data.trigger === T_FUNCTION))\n    { return data }\n\n  var o = {};\n  for (var key in data) {\n    if (!RE_RESERVED_NAMES.test(key)) { o[key] = data[key]; }\n  }\n  return o\n}\n\n/**\n * Set the property of an object for a given key. If something already\n * exists there, then it becomes an array containing both the old and new value.\n * @param { Object } obj - object on which to set the property\n * @param { String } key - property name\n * @param { Object } value - the value of the property to be set\n * @param { Boolean } ensureArray - ensure that the property remains an array\n */\nfunction arrayishAdd(obj, key, value, ensureArray) {\n  var dest = obj[key];\n  var isArr = isArray(dest);\n\n  if (dest && dest === value) { return }\n\n  // if the key was never set, set it once\n  if (!dest && ensureArray) { obj[key] = [value]; }\n  else if (!dest) { obj[key] = value; }\n  // if it was an array and not yet set\n  else if (!isArr || isArr && !contains(dest, value)) {\n    if (isArr) { dest.push(value); }\n    else { obj[key] = [dest, value]; }\n  }\n}\n\n/**\n * Removes an item from an object at a given key. If the key points to an array,\n * then the item is just removed from the array.\n * @param { Object } obj - object on which to remove the property\n * @param { String } key - property name\n * @param { Object } value - the value of the property to be removed\n * @param { Boolean } ensureArray - ensure that the property remains an array\n*/\nfunction arrayishRemove(obj, key, value, ensureArray) {\n  if (isArray(obj[key])) {\n    each(obj[key], function(item, i) {\n      if (item === value) { obj[key].splice(i, 1); }\n    });\n    if (!obj[key].length) { delete obj[key]; }\n    else if (obj[key].length === 1 && !ensureArray) { obj[key] = obj[key][0]; }\n  } else\n    { delete obj[key]; } // otherwise just delete the key\n}\n\n/**\n * Check whether a DOM node is in stub mode, useful for the riot 'if' directive\n * @param   { Object }  dom - DOM node we want to parse\n * @returns { Boolean } -\n */\nfunction isInStub(dom) {\n  while (dom) {\n    if (dom.inStub)\n      { return true }\n    dom = dom.parentNode;\n  }\n  return false\n}\n\n/**\n * Mount a tag creating new Tag instance\n * @param   { Object } root - dom node where the tag will be mounted\n * @param   { String } tagName - name of the riot tag we want to mount\n * @param   { Object } opts - options to pass to the Tag instance\n * @param   { Object } ctx - optional context that will be used to extend an existing class ( used in riot.Tag )\n * @returns { Tag } a new Tag instance\n */\nfunction mountTo(root, tagName, opts, ctx) {\n  var impl = __TAG_IMPL[tagName],\n    implClass = __TAG_IMPL[tagName].class,\n    tag = ctx || (implClass ? Object.create(implClass.prototype) : {}),\n    // cache the inner HTML to fix #855\n    innerHTML = root._innerHTML = root._innerHTML || root.innerHTML;\n\n  // clear the inner html\n  root.innerHTML = '';\n\n  var conf = { root: root, opts: opts };\n  if (opts && opts.parent) { conf.parent = opts.parent; }\n\n  if (impl && root) { Tag$$1.apply(tag, [impl, conf, innerHTML]); }\n\n  if (tag && tag.mount) {\n    tag.mount(true);\n    // add this tag to the virtualDom variable\n    if (!contains(__TAGS_CACHE, tag)) { __TAGS_CACHE.push(tag); }\n  }\n\n  return tag\n}\n\n\n/**\n * Adds the elements for a virtual tag\n * @this Tag\n * @param { Node } src - the node that will do the inserting or appending\n * @param { Tag } target - only if inserting, insert before this tag's first child\n */\nfunction makeVirtual(src, target) {\n  var this$1 = this;\n\n  var head = createDOMPlaceholder(),\n    tail = createDOMPlaceholder(),\n    frag = createFrag(),\n    sib, el;\n\n  this._internal.head = this.root.insertBefore(head, this.root.firstChild);\n  this._internal.tail = this.root.appendChild(tail);\n\n  el = this._internal.head;\n\n  while (el) {\n    sib = el.nextSibling;\n    frag.appendChild(el);\n    this$1._internal.virts.push(el); // hold for unmounting\n    el = sib;\n  }\n\n  if (target)\n    { src.insertBefore(frag, target._internal.head); }\n  else\n    { src.appendChild(frag); }\n}\n\n/**\n * Move virtual tag and all child nodes\n * @this Tag\n * @param { Node } src  - the node that will do the inserting\n * @param { Tag } target - insert before this tag's first child\n */\nfunction moveVirtual(src, target) {\n  var this$1 = this;\n\n  var el = this._internal.head,\n    frag = createFrag(),\n    sib;\n\n  while (el) {\n    sib = el.nextSibling;\n    frag.appendChild(el);\n    el = sib;\n    if (el === this$1._internal.tail) {\n      frag.appendChild(el);\n      src.insertBefore(frag, target._internal.head);\n      break\n    }\n  }\n}\n\n/**\n * Get selectors for tags\n * @param   { Array } tags - tag names to select\n * @returns { String } selector\n */\nfunction selectTags(tags) {\n  // select all tags\n  if (!tags) {\n    var keys = Object.keys(__TAG_IMPL);\n    return keys + selectTags(keys)\n  }\n\n  return tags\n    .filter(function (t) { return !/[^-\\w]/.test(t); })\n    .reduce(function (list, t) {\n      var name = t.trim().toLowerCase();\n      return list + \",[\" + RIOT_TAG_IS + \"=\\\"\" + name + \"\\\"]\"\n    }, '')\n}\n\n\nvar tags = Object.freeze({\n\tgetTag: getTag,\n\tinheritFrom: inheritFrom,\n\tmoveChildTag: moveChildTag,\n\tinitChildTag: initChildTag,\n\tgetImmediateCustomParentTag: getImmediateCustomParentTag,\n\tunmountAll: unmountAll,\n\tgetTagName: getTagName,\n\tcleanUpData: cleanUpData,\n\tarrayishAdd: arrayishAdd,\n\tarrayishRemove: arrayishRemove,\n\tisInStub: isInStub,\n\tmountTo: mountTo,\n\tmakeVirtual: makeVirtual,\n\tmoveVirtual: moveVirtual,\n\tselectTags: selectTags\n});\n\n/**\n * Riot public api\n */\n\nvar settings = Object.create(brackets.settings);\nvar util = {\n  tmpl: tmpl,\n  brackets: brackets,\n  styleManager: styleManager,\n  vdom: __TAGS_CACHE,\n  styleNode: styleManager.styleNode,\n  // export the riot internal utils as well\n  dom: dom,\n  check: check,\n  misc: misc,\n  tags: tags\n};\n\nexports.settings = settings;\nexports.util = util;\nexports.observable = observable;\nexports.Tag = Tag$1;\nexports.tag = tag$$1;\nexports.tag2 = tag2$$1;\nexports.mount = mount$$1;\nexports.mixin = mixin$$1;\nexports.update = update$2;\nexports.unregister = unregister$$1;\n\nObject.defineProperty(exports, '__esModule', { value: true });\n\n})));\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/riot/riot.js\n// module id = 2\n// module chunks = 0","/*\r\n\tMIT License http://www.opensource.org/licenses/mit-license.php\r\n\tAuthor Tobias Koppers @sokra\r\n*/\r\nvar stylesInDom = {},\r\n\tmemoize = function(fn) {\r\n\t\tvar memo;\r\n\t\treturn function () {\r\n\t\t\tif (typeof memo === \"undefined\") memo = fn.apply(this, arguments);\r\n\t\t\treturn memo;\r\n\t\t};\r\n\t},\r\n\tisOldIE = memoize(function() {\r\n\t\treturn /msie [6-9]\\b/.test(window.navigator.userAgent.toLowerCase());\r\n\t}),\r\n\tgetHeadElement = memoize(function () {\r\n\t\treturn document.head || document.getElementsByTagName(\"head\")[0];\r\n\t}),\r\n\tsingletonElement = null,\r\n\tsingletonCounter = 0,\r\n\tstyleElementsInsertedAtTop = [];\r\n\r\nmodule.exports = function(list, options) {\r\n\tif(typeof DEBUG !== \"undefined\" && DEBUG) {\r\n\t\tif(typeof document !== \"object\") throw new Error(\"The style-loader cannot be used in a non-browser environment\");\r\n\t}\r\n\r\n\toptions = options || {};\r\n\t// Force single-tag solution on IE6-9, which has a hard limit on the # of <style>\r\n\t// tags it will allow on a page\r\n\tif (typeof options.singleton === \"undefined\") options.singleton = isOldIE();\r\n\r\n\t// By default, add <style> tags to the bottom of <head>.\r\n\tif (typeof options.insertAt === \"undefined\") options.insertAt = \"bottom\";\r\n\r\n\tvar styles = listToStyles(list);\r\n\taddStylesToDom(styles, options);\r\n\r\n\treturn function update(newList) {\r\n\t\tvar mayRemove = [];\r\n\t\tfor(var i = 0; i < styles.length; i++) {\r\n\t\t\tvar item = styles[i];\r\n\t\t\tvar domStyle = stylesInDom[item.id];\r\n\t\t\tdomStyle.refs--;\r\n\t\t\tmayRemove.push(domStyle);\r\n\t\t}\r\n\t\tif(newList) {\r\n\t\t\tvar newStyles = listToStyles(newList);\r\n\t\t\taddStylesToDom(newStyles, options);\r\n\t\t}\r\n\t\tfor(var i = 0; i < mayRemove.length; i++) {\r\n\t\t\tvar domStyle = mayRemove[i];\r\n\t\t\tif(domStyle.refs === 0) {\r\n\t\t\t\tfor(var j = 0; j < domStyle.parts.length; j++)\r\n\t\t\t\t\tdomStyle.parts[j]();\r\n\t\t\t\tdelete stylesInDom[domStyle.id];\r\n\t\t\t}\r\n\t\t}\r\n\t};\r\n}\r\n\r\nfunction addStylesToDom(styles, options) {\r\n\tfor(var i = 0; i < styles.length; i++) {\r\n\t\tvar item = styles[i];\r\n\t\tvar domStyle = stylesInDom[item.id];\r\n\t\tif(domStyle) {\r\n\t\t\tdomStyle.refs++;\r\n\t\t\tfor(var j = 0; j < domStyle.parts.length; j++) {\r\n\t\t\t\tdomStyle.parts[j](item.parts[j]);\r\n\t\t\t}\r\n\t\t\tfor(; j < item.parts.length; j++) {\r\n\t\t\t\tdomStyle.parts.push(addStyle(item.parts[j], options));\r\n\t\t\t}\r\n\t\t} else {\r\n\t\t\tvar parts = [];\r\n\t\t\tfor(var j = 0; j < item.parts.length; j++) {\r\n\t\t\t\tparts.push(addStyle(item.parts[j], options));\r\n\t\t\t}\r\n\t\t\tstylesInDom[item.id] = {id: item.id, refs: 1, parts: parts};\r\n\t\t}\r\n\t}\r\n}\r\n\r\nfunction listToStyles(list) {\r\n\tvar styles = [];\r\n\tvar newStyles = {};\r\n\tfor(var i = 0; i < list.length; i++) {\r\n\t\tvar item = list[i];\r\n\t\tvar id = item[0];\r\n\t\tvar css = item[1];\r\n\t\tvar media = item[2];\r\n\t\tvar sourceMap = item[3];\r\n\t\tvar part = {css: css, media: media, sourceMap: sourceMap};\r\n\t\tif(!newStyles[id])\r\n\t\t\tstyles.push(newStyles[id] = {id: id, parts: [part]});\r\n\t\telse\r\n\t\t\tnewStyles[id].parts.push(part);\r\n\t}\r\n\treturn styles;\r\n}\r\n\r\nfunction insertStyleElement(options, styleElement) {\r\n\tvar head = getHeadElement();\r\n\tvar lastStyleElementInsertedAtTop = styleElementsInsertedAtTop[styleElementsInsertedAtTop.length - 1];\r\n\tif (options.insertAt === \"top\") {\r\n\t\tif(!lastStyleElementInsertedAtTop) {\r\n\t\t\thead.insertBefore(styleElement, head.firstChild);\r\n\t\t} else if(lastStyleElementInsertedAtTop.nextSibling) {\r\n\t\t\thead.insertBefore(styleElement, lastStyleElementInsertedAtTop.nextSibling);\r\n\t\t} else {\r\n\t\t\thead.appendChild(styleElement);\r\n\t\t}\r\n\t\tstyleElementsInsertedAtTop.push(styleElement);\r\n\t} else if (options.insertAt === \"bottom\") {\r\n\t\thead.appendChild(styleElement);\r\n\t} else {\r\n\t\tthrow new Error(\"Invalid value for parameter 'insertAt'. Must be 'top' or 'bottom'.\");\r\n\t}\r\n}\r\n\r\nfunction removeStyleElement(styleElement) {\r\n\tstyleElement.parentNode.removeChild(styleElement);\r\n\tvar idx = styleElementsInsertedAtTop.indexOf(styleElement);\r\n\tif(idx >= 0) {\r\n\t\tstyleElementsInsertedAtTop.splice(idx, 1);\r\n\t}\r\n}\r\n\r\nfunction createStyleElement(options) {\r\n\tvar styleElement = document.createElement(\"style\");\r\n\tstyleElement.type = \"text/css\";\r\n\tinsertStyleElement(options, styleElement);\r\n\treturn styleElement;\r\n}\r\n\r\nfunction createLinkElement(options) {\r\n\tvar linkElement = document.createElement(\"link\");\r\n\tlinkElement.rel = \"stylesheet\";\r\n\tinsertStyleElement(options, linkElement);\r\n\treturn linkElement;\r\n}\r\n\r\nfunction addStyle(obj, options) {\r\n\tvar styleElement, update, remove;\r\n\r\n\tif (options.singleton) {\r\n\t\tvar styleIndex = singletonCounter++;\r\n\t\tstyleElement = singletonElement || (singletonElement = createStyleElement(options));\r\n\t\tupdate = applyToSingletonTag.bind(null, styleElement, styleIndex, false);\r\n\t\tremove = applyToSingletonTag.bind(null, styleElement, styleIndex, true);\r\n\t} else if(obj.sourceMap &&\r\n\t\ttypeof URL === \"function\" &&\r\n\t\ttypeof URL.createObjectURL === \"function\" &&\r\n\t\ttypeof URL.revokeObjectURL === \"function\" &&\r\n\t\ttypeof Blob === \"function\" &&\r\n\t\ttypeof btoa === \"function\") {\r\n\t\tstyleElement = createLinkElement(options);\r\n\t\tupdate = updateLink.bind(null, styleElement);\r\n\t\tremove = function() {\r\n\t\t\tremoveStyleElement(styleElement);\r\n\t\t\tif(styleElement.href)\r\n\t\t\t\tURL.revokeObjectURL(styleElement.href);\r\n\t\t};\r\n\t} else {\r\n\t\tstyleElement = createStyleElement(options);\r\n\t\tupdate = applyToTag.bind(null, styleElement);\r\n\t\tremove = function() {\r\n\t\t\tremoveStyleElement(styleElement);\r\n\t\t};\r\n\t}\r\n\r\n\tupdate(obj);\r\n\r\n\treturn function updateStyle(newObj) {\r\n\t\tif(newObj) {\r\n\t\t\tif(newObj.css === obj.css && newObj.media === obj.media && newObj.sourceMap === obj.sourceMap)\r\n\t\t\t\treturn;\r\n\t\t\tupdate(obj = newObj);\r\n\t\t} else {\r\n\t\t\tremove();\r\n\t\t}\r\n\t};\r\n}\r\n\r\nvar replaceText = (function () {\r\n\tvar textStore = [];\r\n\r\n\treturn function (index, replacement) {\r\n\t\ttextStore[index] = replacement;\r\n\t\treturn textStore.filter(Boolean).join('\\n');\r\n\t};\r\n})();\r\n\r\nfunction applyToSingletonTag(styleElement, index, remove, obj) {\r\n\tvar css = remove ? \"\" : obj.css;\r\n\r\n\tif (styleElement.styleSheet) {\r\n\t\tstyleElement.styleSheet.cssText = replaceText(index, css);\r\n\t} else {\r\n\t\tvar cssNode = document.createTextNode(css);\r\n\t\tvar childNodes = styleElement.childNodes;\r\n\t\tif (childNodes[index]) styleElement.removeChild(childNodes[index]);\r\n\t\tif (childNodes.length) {\r\n\t\t\tstyleElement.insertBefore(cssNode, childNodes[index]);\r\n\t\t} else {\r\n\t\t\tstyleElement.appendChild(cssNode);\r\n\t\t}\r\n\t}\r\n}\r\n\r\nfunction applyToTag(styleElement, obj) {\r\n\tvar css = obj.css;\r\n\tvar media = obj.media;\r\n\r\n\tif(media) {\r\n\t\tstyleElement.setAttribute(\"media\", media)\r\n\t}\r\n\r\n\tif(styleElement.styleSheet) {\r\n\t\tstyleElement.styleSheet.cssText = css;\r\n\t} else {\r\n\t\twhile(styleElement.firstChild) {\r\n\t\t\tstyleElement.removeChild(styleElement.firstChild);\r\n\t\t}\r\n\t\tstyleElement.appendChild(document.createTextNode(css));\r\n\t}\r\n}\r\n\r\nfunction updateLink(linkElement, obj) {\r\n\tvar css = obj.css;\r\n\tvar sourceMap = obj.sourceMap;\r\n\r\n\tif(sourceMap) {\r\n\t\t// http://stackoverflow.com/a/26603875\r\n\t\tcss += \"\\n/*# sourceMappingURL=data:application/json;base64,\" + btoa(unescape(encodeURIComponent(JSON.stringify(sourceMap)))) + \" */\";\r\n\t}\r\n\r\n\tvar blob = new Blob([css], { type: \"text/css\" });\r\n\r\n\tvar oldSrc = linkElement.href;\r\n\r\n\tlinkElement.href = URL.createObjectURL(blob);\r\n\r\n\tif(oldSrc)\r\n\t\tURL.revokeObjectURL(oldSrc);\r\n}\r\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/style-loader/addStyles.js\n// module id = 3\n// module chunks = 0","'use strict'\nconst riot = require('riot')\n\nrequire('./app.tag')\nriot.mount('app')\n\n// Router\n//require('./router.js')\n// SASS\nrequire('./stylesheets/normalize.scss')\nrequire('./stylesheets/flex-grid.scss')\nrequire('./stylesheets/default-hljs.scss')\n\n\n\n// WEBPACK FOOTER //\n// ./client/index.js","\nriot.tag2('require', '', '', 'components layouts basic-layout tag', function(opts) {\n});\n\n\n\n\n\n\n\n\n\n\n\nriot.tag2('app', '<basic-layout></basic-layout> <h1>hogehoge</h1>', '', '', function(opts) {\n});\n\n\n// WEBPACK FOOTER //\n// ./client/app.tag","exports = module.exports = require(\"./../../node_modules/css-loader/lib/css-base.js\")();\n// imports\n\n\n// module\nexports.push([module.id, \".hljs{display:block;overflow-x:auto;padding:.5em;background:#f0f0f0;-webkit-text-size-adjust:none}.hljs,.hljs-subst,.hljs-tag .hljs-title,.nginx .hljs-title{color:#000}.apache .hljs-cbracket,.apache .hljs-tag,.asciidoc .hljs-header,.bash .hljs-variable,.coffeescript .hljs-attribute,.django .hljs-variable,.erlang_repl .hljs-function_or_atom,.haml .hljs-symbol,.hljs-addition,.hljs-constant,.hljs-flow,.hljs-name,.hljs-parent,.hljs-pragma,.hljs-preprocessor,.hljs-rule .hljs-value,.hljs-stream,.hljs-string,.hljs-tag .hljs-value,.hljs-template_tag,.hljs-title,.markdown .hljs-header,.pf .hljs-variable,.ruby .hljs-symbol,.ruby .hljs-symbol .hljs-string,.smalltalk .hljs-class,.tex .hljs-command,.tex .hljs-special,.tp .hljs-variable{color:#800}.asciidoc .hljs-blockquote,.diff .hljs-header,.hljs-annotation,.hljs-chunk,.hljs-comment,.markdown .hljs-blockquote,.smartquote{color:#888}.asciidoc .hljs-bullet,.asciidoc .hljs-link_url,.go .hljs-constant,.hljs-change,.hljs-date,.hljs-hexcolor,.hljs-literal,.hljs-number,.hljs-regexp,.lasso .hljs-variable,.makefile .hljs-variable,.markdown .hljs-bullet,.markdown .hljs-link_url,.smalltalk .hljs-char,.smalltalk .hljs-symbol{color:#080}.apache .hljs-sqbracket,.asciidoc .hljs-attribute,.asciidoc .hljs-link_label,.clojure .hljs-attribute,.coffeescript .hljs-property,.erlang_repl .hljs-reserved,.haml .hljs-bullet,.hljs-array,.hljs-attr_selector,.hljs-decorator,.hljs-deletion,.hljs-doctype,.hljs-envvar,.hljs-filter .hljs-argument,.hljs-important,.hljs-label,.hljs-localvars,.hljs-phony,.hljs-pi,.hljs-prompt,.hljs-pseudo,.hljs-shebang,.lasso .hljs-attribute,.markdown .hljs-link_label,.nginx .hljs-built_in,.ruby .hljs-string,.tex .hljs-formula,.vhdl .hljs-attribute{color:#88f}.apache .hljs-tag,.asciidoc .hljs-strong,.bash .hljs-variable,.css .hljs-tag,.hljs-built_in,.hljs-doctag,.hljs-id,.hljs-keyword,.hljs-request,.hljs-status,.hljs-title,.hljs-type,.hljs-typename,.hljs-winutils,.markdown .hljs-strong,.pf .hljs-variable,.smalltalk .hljs-class,.tex .hljs-command,.tp .hljs-data,.tp .hljs-io{font-weight:700}.asciidoc .hljs-emphasis,.markdown .hljs-emphasis,.tp .hljs-units{font-style:italic}.nginx .hljs-built_in{font-weight:400}.coffeescript .javascript,.javascript .xml,.lasso .markup,.tex .hljs-formula,.xml .css,.xml .hljs-cdata,.xml .javascript,.xml .vbscript{opacity:.5}\", \"\"]);\n\n// exports\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/css-loader!./~/sass-loader!./client/stylesheets/default-hljs.scss\n// module id = 6\n// module chunks = 0","exports = module.exports = require(\"./../../node_modules/css-loader/lib/css-base.js\")();\n// imports\n\n\n// module\nexports.push([module.id, \".row{box-sizing:border-box;display:flex;flex-direction:row;flex-wrap:wrap;margin-left:-.5rem;margin-right:-.5rem}.col-lg,.col-lg-1,.col-lg-2,.col-lg-3,.col-lg-4,.col-lg-5,.col-lg-6,.col-lg-7,.col-lg-8,.col-lg-9,.col-lg-10,.col-lg-11,.col-lg-12,.col-md,.col-md-1,.col-md-2,.col-md-3,.col-md-4,.col-md-5,.col-md-6,.col-md-7,.col-md-8,.col-md-9,.col-md-10,.col-md-11,.col-md-12,.col-sm,.col-sm-1,.col-sm-2,.col-sm-3,.col-sm-4,.col-sm-5,.col-sm-6,.col-sm-7,.col-sm-8,.col-sm-9,.col-sm-10,.col-sm-11,.col-sm-12,.col-xs,.col-xs-1,.col-xs-2,.col-xs-3,.col-xs-4,.col-xs-5,.col-xs-6,.col-xs-7,.col-xs-8,.col-xs-9,.col-xs-10,.col-xs-11,.col-xs-12{box-sizing:border-box;display:flex;flex-direction:column;flex-grow:0;flex-shrink:0;padding-left:.5rem;padding-right:.5rem}.col-lg,.col-md,.col-sm,.col-xs{flex-grow:1;flex-basis:0;max-width:100%}.col-xs-1{flex-basis:8.33333%;max-width:8.33333%}.col-xs-2{flex-basis:16.66667%;max-width:16.66667%}.col-xs-3{flex-basis:25%;max-width:25%}.col-xs-4{flex-basis:33.33333%;max-width:33.33333%}.col-xs-5{flex-basis:41.66667%;max-width:41.66667%}.col-xs-6{flex-basis:50%;max-width:50%}.col-xs-7{flex-basis:58.33333%;max-width:58.33333%}.col-xs-8{flex-basis:66.66667%;max-width:66.66667%}.col-xs-9{flex-basis:75%;max-width:75%}.col-xs-10{flex-basis:83.33333%;max-width:83.33333%}.col-xs-11{flex-basis:91.66667%;max-width:91.66667%}.col-xs-12{flex-basis:100%;max-width:100%}.off-xs-1{margin-left:8.33333%}.off-xs-2{margin-left:16.66667%}.off-xs-3{margin-left:25%}.off-xs-4{margin-left:33.33333%}.off-xs-5{margin-left:41.66667%}.off-xs-6{margin-left:50%}.off-xs-7{margin-left:58.33333%}.off-xs-8{margin-left:66.66667%}.off-xs-9{margin-left:75%}.off-xs-10{margin-left:83.33333%}.off-xs-11{margin-left:91.66667%}@media only screen and (min-width:768px){.col-sm-1{flex-basis:8.33333%;max-width:8.33333%}.col-sm-2{flex-basis:16.66667%;max-width:16.66667%}.col-sm-3{flex-basis:25%;max-width:25%}.col-sm-4{flex-basis:33.33333%;max-width:33.33333%}.col-sm-5{flex-basis:41.66667%;max-width:41.66667%}.col-sm-6{flex-basis:50%;max-width:50%}.col-sm-7{flex-basis:58.33333%;max-width:58.33333%}.col-sm-8{flex-basis:66.66667%;max-width:66.66667%}.col-sm-9{flex-basis:75%;max-width:75%}.col-sm-10{flex-basis:83.33333%;max-width:83.33333%}.col-sm-11{flex-basis:91.66667%;max-width:91.66667%}.col-sm-12{flex-basis:100%;max-width:100%}.off-sm-1{margin-left:8.33333%}.off-sm-2{margin-left:16.66667%}.off-sm-3{margin-left:25%}.off-sm-4{margin-left:33.33333%}.off-sm-5{margin-left:41.66667%}.off-sm-6{margin-left:50%}.off-sm-7{margin-left:58.33333%}.off-sm-8{margin-left:66.66667%}.off-sm-9{margin-left:75%}.off-sm-10{margin-left:83.33333%}.off-sm-11{margin-left:91.66667%}}@media only screen and (min-width:992px){.col-md-1{flex-basis:8.33333%;max-width:8.33333%}.col-md-2{flex-basis:16.66667%;max-width:16.66667%}.col-md-3{flex-basis:25%;max-width:25%}.col-md-4{flex-basis:33.33333%;max-width:33.33333%}.col-md-5{flex-basis:41.66667%;max-width:41.66667%}.col-md-6{flex-basis:50%;max-width:50%}.col-md-7{flex-basis:58.33333%;max-width:58.33333%}.col-md-8{flex-basis:66.66667%;max-width:66.66667%}.col-md-9{flex-basis:75%;max-width:75%}.col-md-10{flex-basis:83.33333%;max-width:83.33333%}.col-md-11{flex-basis:91.66667%;max-width:91.66667%}.col-md-12{flex-basis:100%;max-width:100%}.off-md-1{margin-left:8.33333%}.off-md-2{margin-left:16.66667%}.off-md-3{margin-left:25%}.off-md-4{margin-left:33.33333%}.off-md-5{margin-left:41.66667%}.off-md-6{margin-left:50%}.off-md-7{margin-left:58.33333%}.off-md-8{margin-left:66.66667%}.off-md-9{margin-left:75%}.off-md-10{margin-left:83.33333%}.off-md-11{margin-left:91.66667%}}@media only screen and (min-width:1200px){.col-lg-1{flex-basis:8.33333%;max-width:8.33333%}.col-lg-2{flex-basis:16.66667%;max-width:16.66667%}.col-lg-3{flex-basis:25%;max-width:25%}.col-lg-4{flex-basis:33.33333%;max-width:33.33333%}.col-lg-5{flex-basis:41.66667%;max-width:41.66667%}.col-lg-6{flex-basis:50%;max-width:50%}.col-lg-7{flex-basis:58.33333%;max-width:58.33333%}.col-lg-8{flex-basis:66.66667%;max-width:66.66667%}.col-lg-9{flex-basis:75%;max-width:75%}.col-lg-10{flex-basis:83.33333%;max-width:83.33333%}.col-lg-11{flex-basis:91.66667%;max-width:91.66667%}.col-lg-12{flex-basis:100%;max-width:100%}.off-lg-1{margin-left:8.33333%}.off-lg-2{margin-left:16.66667%}.off-lg-3{margin-left:25%}.off-lg-4{margin-left:33.33333%}.off-lg-5{margin-left:41.66667%}.off-lg-6{margin-left:50%}.off-lg-7{margin-left:58.33333%}.off-lg-8{margin-left:66.66667%}.off-lg-9{margin-left:75%}.off-lg-10{margin-left:83.33333%}.off-lg-11{margin-left:91.66667%}}\", \"\"]);\n\n// exports\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/css-loader!./~/sass-loader!./client/stylesheets/flex-grid.scss\n// module id = 7\n// module chunks = 0","exports = module.exports = require(\"./../../node_modules/css-loader/lib/css-base.js\")();\n// imports\n\n\n// module\nexports.push([module.id, \"html{font-family:sans-serif;-ms-text-size-adjust:100%;-webkit-text-size-adjust:100%}body{margin:0}article,aside,details,figcaption,figure,footer,header,hgroup,main,menu,nav,section,summary{display:block}audio,canvas,progress,video{display:inline-block;vertical-align:baseline}audio:not([controls]){display:none;height:0}[hidden],template{display:none}a{background-color:transparent}a:active,a:hover{outline:0}abbr[title]{border-bottom:1px dotted}b,strong{font-weight:700}dfn{font-style:italic}h1{font-size:2em;margin:.67em 0}mark{background:#ff0;color:#000}small{font-size:80%}sub,sup{font-size:75%;line-height:0;position:relative;vertical-align:baseline}sup{top:-.5em}sub{bottom:-.25em}img{border:0}svg:not(:root){overflow:hidden}figure{margin:1em 40px}hr{box-sizing:content-box;height:0}pre{overflow:auto}code,kbd,pre,samp{font-family:monospace,monospace;font-size:1em}button,input,optgroup,select,textarea{color:inherit;font:inherit;margin:0}button{overflow:visible}button,select{text-transform:none}button,html input[type=button],input[type=reset],input[type=submit]{-webkit-appearance:button;cursor:pointer}button[disabled],html input[disabled]{cursor:default}button::-moz-focus-inner,input::-moz-focus-inner{border:0;padding:0}input{line-height:normal}input[type=checkbox],input[type=radio]{box-sizing:border-box;padding:0}input[type=number]::-webkit-inner-spin-button,input[type=number]::-webkit-outer-spin-button{height:auto}input[type=search]{-webkit-appearance:textfield;box-sizing:content-box}input[type=search]::-webkit-search-cancel-button,input[type=search]::-webkit-search-decoration{-webkit-appearance:none}fieldset{border:1px solid silver;margin:0 2px;padding:.35em .625em .75em}legend{border:0;padding:0}textarea{overflow:auto}optgroup{font-weight:700}table{border-collapse:collapse;border-spacing:0}td,th{padding:0}\", \"\"]);\n\n// exports\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/css-loader!./~/sass-loader!./client/stylesheets/normalize.scss\n// module id = 8\n// module chunks = 0","// style-loader: Adds some css to the DOM by adding a <style> tag\n\n// load the styles\nvar content = require(\"!!./../../node_modules/css-loader/index.js!./../../node_modules/sass-loader/index.js!./default-hljs.scss\");\nif(typeof content === 'string') content = [[module.id, content, '']];\n// add the styles to the DOM\nvar update = require(\"!./../../node_modules/style-loader/addStyles.js\")(content, {});\nif(content.locals) module.exports = content.locals;\n// Hot Module Replacement\nif(module.hot) {\n\t// When the styles change, update the <style> tags\n\tif(!content.locals) {\n\t\tmodule.hot.accept(\"!!./../../node_modules/css-loader/index.js!./../../node_modules/sass-loader/index.js!./default-hljs.scss\", function() {\n\t\t\tvar newContent = require(\"!!./../../node_modules/css-loader/index.js!./../../node_modules/sass-loader/index.js!./default-hljs.scss\");\n\t\t\tif(typeof newContent === 'string') newContent = [[module.id, newContent, '']];\n\t\t\tupdate(newContent);\n\t\t});\n\t}\n\t// When the module is disposed, remove the <style> tags\n\tmodule.hot.dispose(function() { update(); });\n}\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./client/stylesheets/default-hljs.scss\n// module id = 9\n// module chunks = 0","// style-loader: Adds some css to the DOM by adding a <style> tag\n\n// load the styles\nvar content = require(\"!!./../../node_modules/css-loader/index.js!./../../node_modules/sass-loader/index.js!./flex-grid.scss\");\nif(typeof content === 'string') content = [[module.id, content, '']];\n// add the styles to the DOM\nvar update = require(\"!./../../node_modules/style-loader/addStyles.js\")(content, {});\nif(content.locals) module.exports = content.locals;\n// Hot Module Replacement\nif(module.hot) {\n\t// When the styles change, update the <style> tags\n\tif(!content.locals) {\n\t\tmodule.hot.accept(\"!!./../../node_modules/css-loader/index.js!./../../node_modules/sass-loader/index.js!./flex-grid.scss\", function() {\n\t\t\tvar newContent = require(\"!!./../../node_modules/css-loader/index.js!./../../node_modules/sass-loader/index.js!./flex-grid.scss\");\n\t\t\tif(typeof newContent === 'string') newContent = [[module.id, newContent, '']];\n\t\t\tupdate(newContent);\n\t\t});\n\t}\n\t// When the module is disposed, remove the <style> tags\n\tmodule.hot.dispose(function() { update(); });\n}\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./client/stylesheets/flex-grid.scss\n// module id = 10\n// module chunks = 0","// style-loader: Adds some css to the DOM by adding a <style> tag\n\n// load the styles\nvar content = require(\"!!./../../node_modules/css-loader/index.js!./../../node_modules/sass-loader/index.js!./normalize.scss\");\nif(typeof content === 'string') content = [[module.id, content, '']];\n// add the styles to the DOM\nvar update = require(\"!./../../node_modules/style-loader/addStyles.js\")(content, {});\nif(content.locals) module.exports = content.locals;\n// Hot Module Replacement\nif(module.hot) {\n\t// When the styles change, update the <style> tags\n\tif(!content.locals) {\n\t\tmodule.hot.accept(\"!!./../../node_modules/css-loader/index.js!./../../node_modules/sass-loader/index.js!./normalize.scss\", function() {\n\t\t\tvar newContent = require(\"!!./../../node_modules/css-loader/index.js!./../../node_modules/sass-loader/index.js!./normalize.scss\");\n\t\t\tif(typeof newContent === 'string') newContent = [[module.id, newContent, '']];\n\t\t\tupdate(newContent);\n\t\t});\n\t}\n\t// When the module is disposed, remove the <style> tags\n\tmodule.hot.dispose(function() { update(); });\n}\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./client/stylesheets/normalize.scss\n// module id = 11\n// module chunks = 0"],"sourceRoot":""}